#+STARTUP: showall
#+OPTIONS: todo:nil tasks:nil tags:nil toc:nil
#+PROPERTY: header-args :eval never-export
#+PROPERTY: header-args :results output pp replace
#+EXCLUDE_TAGS: noexport
#+LATEX_HEADER: \usepackage{breakurl}
#+LATEX_HEADER: \usepackage{newuli}
#+LATEX_HEADER: \usepackage{uli-german-paragraphs}

* The print statement
Note, the terms "statement" and "function" are used interchangeably. 

** Recap
Note, in the following, the terms "statement" and "function" are used
interchangeably.  Over the course of the last couple of modules, we
implicitly learned (hopefully), a couple of essential things about
python. Here a summary. If any of these concepts or terms are unclear,
please go back to the previous modules and discuss with your TA/Prof
where necessary.

  1. While python understands decimal numbers without help, we have to
     mark strings with quotation marks (otherwise python would think
     it is a variable or function name): =s = "Hello World"=
  2. It matters how we use brackets:
     * Square brackets to the right of an equal sign indicate that you
       declare a list: =a = [1, 2, 4]=. Square brackets to the right
       of a name or letter indicate an index expression: =a[1] =
       22=. Index expressions can also be used to address ranges and
       stepsize: =a[1:2:1]=.
     * Round brackets to the right of an equal sign are used to
       declare a tuple: =t=(1, 2, 3)=, whereas round brackets to the
       right of a name indicates that this name is a function:
       =print()=. Note that to access the 2^{nd} element of the tuple,
       you will still have to use square brackets since you are doing
       and index operation: =t[1]=. Tuples are immutable.
     * Curly braces to the right are used to declare a set: =u =
       {1,2,3}=. Set members cannot be retrieved by an index
       operation, and set values are immutable.
     * But they are also used to declare dictionaries. In this case,
       the declaration contains key:value pairs that are separated by
       a colon. =d = {"B":12, "A":14, "C":7}=. Dictionary entries can
       be retrieved by using an index expression using the dictionary
       key: =d["B"]=
  3. A name followed by regular brackets denotes a python function:
     =print()=. Functions exist independently of data (or objects like lists).
  4. A name followed by a dot and another name with brackets denotes
     an object method: =a.sort()= which only exists as long as the
     object exists.
     * Object methods can either modify the object associated data in
       place, e.g., =a.sort()=
     * Or, they do not modify the object associated data, but instead
       return a copy of the data, e.g., =s.split(",")=. So if you
       would like to change the original data set, you would have to
       write =s = s.split(",")=.
  5. We can query the object type with the type function: =type(a)=,
     we can list the object associated methods with the dir function:
     =dir(a)=
  6. We can get help on python functions with the help command:
     =help(print)=
  7. We can get help on object methods with the help function:
     =help(a.pop)=
  8. The name of a compound variable (i.e., lists, tuples,
     dictionaries etc.) refers to its object handle, not it's value.
     Thus, the expression =my_new_list = my_old_list= will not copy
     the list values, it will only copy the memory address where those
     values are stored. In other words, if you modify =my_new_list=
     you will also modify =my_old_list=. To create an independent copy
     you need to use the copy method: =my_new_list =
     my_old_list.copy()=
   
   
** Using print()
@@latex:\index{functions!print()} \index{print()}@@ By now, you probably
noticed that the print statement is a function. Functions
 @@latex:\index{Functions} \index{python!functions!argument}@@ usually take one
or more arguments (i.e., data or variables), which are enclosed by
regular brackets, and then do something with that data. We use the
print function so far, simply to echo the value of a variable back
onto the screen. There is however, much more we can do with this
function, and we will make extensive use of this capability. This
module will teach the basics of producing formatted
output.  @@latex:\index{output!formatted} \index{formatted output}@@

Most things python are straightforward, but the syntax of the print
function is not. This is simply because every new python version
provides new ways to format the print output. In this course, we will
use the syntax provided by python 3.7, the so-called f-strings. You
will note that this is different from the syntax explained in your
book or what you will find on legacy systems, which may still run
python 2.7. If you run into these cases, the internet is your friend.

** F-strings
 @@latex:\index{strings!f-strings}
 \index{python!functions!print()!f-strings}@@ @@latex:\index{formatted
 output!f-strings} \index{print()!f-strings}@@ The =print()=
 statement, allows us to display the value of a variable.

#+BEGIN_SRC ipython
a = 2
b = 4
c = a * b
print(c)
#+END_SRC

#+RESULTS:
: # Out [1]: 
: # output
: 8
: 

this is handy enough while you develop your code, but it would be nice
if could print something more meaningful, e.g., "The square-root of 12
equals 4".

In other words, we need a way to mix strings with variable
values. This is achieved with the so-called "f-strings" (python 3.7
and newer only).

#+BEGIN_SRC ipython
a = 2
b = 4
c = a * b
message = f"Multiplying {a} with {b} yields {c}"
print(message)
#+END_SRC

#+RESULTS:
: # Out [2]: 
: # output
: Multiplying 2 with 4 yields 8
: 

Let's analyze the above example: we precede the string declaration in
line 4 with an =f= which signals to python that this string will be an
f-string. As usual, we enclose the string in quotation marks. After
the opening quotation marks, we have some text, which will be output
as is. However, in f-strings anything between the curly braces will be
interpreted as python code. This can be a variable, a function, or any
other valid python expression. Try the following to verify this claim
#+BEGIN_SRC ipython
a = 12
print(f"Four times {a} equals {4*a}")
#+END_SRC

#+RESULTS:
: # Out [3]: 
: # output
: Four times 12 equals 48
: 

This provides us with a powerful way to mix text and computational
results.


** Escape sequences
 @@latex:\index{Escape Sequences} \index{python!functions!print()!Escape Sequences} \index{formatted output!Escape Sequences} \index{print()!Escape Sequences}@@
Imagine that you need to print more than one line, e.g., something like this:
#+BEGIN_EXAMPLE
----------------------------

       Attention! 

----------------------------
#+END_EXAMPLE
This can be achieved in a variety of ways, e.g., we could create the
above explicitly
#+BEGIN_SRC ipython
print(" - - - - - - - - - - - - - -")
print()
print("       Attention!")
print()
print(" - - - - - - - - - - - - - -")
#+END_SRC

#+RESULTS:
: # Out [4]: 
: # output
:  - - - - - - - - - - - - - -
: 
:        Attention!
: 
:  - - - - - - - - - - - - - -
: 


Not a bad way, but lots of typing. If we could tell python to insert a
newline, and tab, we could rewrite this statement in a much shorter
way. This is done with so called escape-characters.
#+BEGIN_SRC ipython 
a = " - - - - - - - - - - - - - -"
message=f"{a} \n\n \t Attention! \n\n{a}"
print(message)
#+END_SRC

#+RESULTS:
: # Out [5]: 
: # output
:  - - - - - - - - - - - - - - 
: 
:       Attention! 
: 
:  - - - - - - - - - - - - - -
: 

In python (and many other languages as well) the backslash is a
control character which denotes that the character after the backslash
has a special meaning. So in the above example, the sequence of =\n=
will be replaced with a linefeed command (i.e., an empty line), and
the =\t= will be replaced by a tab. Furthermore, you can use the
backslash to indicate that the following character should not be
interpreted as a special command. Imagine a case where you want to
print the backslash in your output. This is done by preceding the
backslash with a backslash. This is also called to escape the
backslash.
#+BEGIN_SRC ipython
message="Print a newline here: \nprint the backslash here: \\"
print(message)
#+END_SRC

#+RESULTS:
: # Out [6]: 
: # output
: Print a newline here: 
: print the backslash here: \
: 

Here a list of some frequently used escape sequences. Note, if you use
these in your notebook text cells, you need to wrap them into a code
block (triple backticks). Escape sequences are not part of the
markdown syntax and cause all sorts of weird problems (among them
missing pdf output) @@latex:\index{missing pdf output}@@

| Escape Sequence | Meaning                                   |
|-----------------+-------------------------------------------|
| <>              | <>                                        |
| =\newline=      | Ignored                                   |
| =\=             | Backslash (\)                             |
| =\'=            | Single quote (')                          |
| =\"=            | Double quote (")                          |
| =\a=            | ASCII Bell (BEL)                          |
| =\b=            | ASCII Backspace (BS)                      |
| =\f=            | ASCII Formfeed (FF)                       |
| =\n=            | ASCII Linefeed (LF)                       |
| =\r=            | ASCII Carriage Return (CR)                |
| =\t=            | ASCII Horizontal Tab (TAB)                |
| =\v=            | ASCII Vertical Tab (VT)                   |
| =\xA1=          | ASCII character with hexadecimal value A1 |
| =\135=          | ASCII character with octal value 135 (])  |

** Multiline f-strings

@@latex:\index{f-strings!multiline}@@
@@latex:\index{python!functions!print()!f-strings!multiline}@@ 
@@latex:\index{formatted output!f-strings!multiline}@@  
@@latex:\index{print()!f-strings!multiline}@@
@@latex:\index{multiline f-strings} \index{strings!f-strings!multiline}@@
@@latex:\index{strings!multiline}@@

Sometimes, your message string won't fit on a single line. In this case, we can group several f-strings together
#+BEGIN_SRC ipython
message = (
    f"This is the first string"
    f"This is the second string"
)
print(message)
#+END_SRC

#+RESULTS:
: # Out [7]: 
: # output
: This is the first stringThis is the second string
: 

You will note that the above does not automatically include
linefeeds. I.e., you will need to add the appropriate escape sequences
into the f-string.


** Format modifiers
 @@latex:\index{format modifiers!print} \index{print!format modifiers}@@

The above gives us already a lot of control over the output from a
python program. However, consider the case where you get measurements
from an analytical instrument, which reports the data as
12.3456006423.  However, the actual instrument precision is only
around 0.2. There, it would be nice to restrict the output of the
print statement to the significant figures.

This is done with so called format modifiers. Try this:
#+BEGIN_SRC ipython
a =  12.3456006423
print(f"The value of variable a equals {a}")
# now we add a format modifier
print(f"The value of variable a equals {a:1.2f}")
#+END_SRC

#+RESULTS:
: # Out [8]: 
: # output
: The value of variable a equals 12.3456006423
: The value of variable a equals 12.35
: 

Let's analyze this statement. We use a colon after the variable name
to attach a format modifier (note this method is specific to
f-strings). The first number states that our output must have a
minimum length of 1, with no more than two digits after the decimal
point. Modify this statement in such a way that you print the result
with 3 and 4 significant figures. Also, does this operation simply
truncate the number, or will the number be rounded?

The first number in the format modifier specifies the minimum length
of the statement. I.e., if this number is larger than the length of
the actual output (in the above case 4 characters), the result will be
padded with leading spaces. This can be important when saving data in
a format which requires that the decimal point is always at the 7^{th}
character position.

Similarly, python knows the "s" format modifier for strings. This can
be used to
 * truncate long strings
 * pad them with blanks on the left
 * pad them with blanks on the right
#+BEGIN_SRC ipython
message = "Hello World"
print(f"The content of the message string = {message:.4s} - so what?")
print(f"The content of the message string = {message:>20s} - so what?")
print(f"The content of the message string = {message:<20s} - so what?")
#+END_SRC

#+RESULTS:
: # Out [9]: 
: # output
: The content of the message string = Hell - so what?
: The content of the message string =          Hello World - so what?
: The content of the message string = Hello World          - so what?
: 

Likewise, we can use the "d" modifier to pad integer numbers, or force
python to print the sign of the number (which is always done for
negative values, but usually omitted for positive ones.
#+BEGIN_SRC ipython
a = 12347687
print(f"a = {a:>20d} - so what?")
print(f"a = {a:<20d} - so what?")
print(f"a = ${a:+d} - so what?")
#+END_SRC

#+RESULTS:
: # Out [10]: 
: # output
: a =             12347687 - so what?
: a = 12347687             - so what?
: a = $+12347687 - so what?
: 

Note that you cannot use modifiers to display floating point numbers
as integer or string.



# print a value as currency rounded to cents # point of sale system example?
