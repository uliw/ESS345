#+STARTUP: showall
#+OPTIONS: todo:nil tasks:nil tags:nil toc:nil
#+PROPERTY: header-args :eval never-export
#+PROPERTY: header-args :results output pp replace
#+EXCLUDE_TAGS: noexport
#+LATEX_HEADER: \usepackage{breakurl}
#+LATEX_HEADER: \usepackage{newuli}
#+LATEX_HEADER: \usepackage{uli-german-paragraphs}



* Comparison and Logic operators

Program code, which only ever executes the same sequence of events, is
somewhat limited.  As such, we need a way to change program execution
depending on the occurrence of certain circumstances (typically the
value of a variable). We, therefore, need a way to compare values of
variables and decide, e.g., whether one variable is equal to another.


** Comparison operators
 @@latex:\index{operators!comparison} \index{comparison operators}@@
If we want to compare two numbers, we obviously cannot use the equal
sign
#+BEGIN_SRC ipython
a = 12
b = 14
a = b  # this assigns the value of b to a
#+END_SRC

#+RESULTS:
: # Out [1]: 

In most programming languages, it is thus customary to write a double
equal sign, to denote a comparison.

#+BEGIN_SRC ipython
a = 12
b = 14
a == b  # this compares the value of b to a
#+END_SRC

#+RESULTS:
: # Out [2]: 
: # text/plain
: : False

Unlike numeric operators, comparisons do not result in a numeric
value, rather, they result in truth values (also referred to as logic
or boolean value). In other words, two numbers are either equal (so
the statement is =True=) or they are not equal. Thus the statement is
=False=

Most languages signify this by reporting this with the reserved words
of =True= or =False=. Since there are only two logical states, boolean
values can be represented by a single bit (i.e., either 0 or
1). Compare this to the memory requirements of a regular integer value
(64-bit). 

The basic comparisons operators are as follows:
#+BEGIN_SRC ipython
5 == 4  # test for equality
2 != 3  # test whether two values are not equal
5 > 4   # test for greater value
5 < 4   # test for smaller value
1 >= 1  # test for greater or equal value
2 <= 2  # test for smaller or equal value
#+END_SRC

#+RESULTS:
: # Out [3]: 
: # text/plain
: : True

We can use the above operators in one way or another on most python
data types, although you have to be careful to understand what is
being compared. If we are comparing strings, the equality operator
will tell you if two strings are the same or not. Run the
following code:
#+BEGIN_SRC ipython
print(f'"Apples" == "Apples" yields {"Apples" == "Apples"}')
print(f'"Apples" == "Oranges" yields {"Apples" == "Oranges"}')
#+END_SRC

#+RESULTS:
: # Out [4]: 
: # output
: "Apples" == "Apples" yields True
: "Apples" == "Oranges" yields False
: 

Note the use of single quotes in the above f-string, which allows me
to use double quotes inside the f-string.

But what is the point of 
#+BEGIN_SRC ipython
print(f'"Apples" < "Oranges" yields {"Apples" < "Oranges"}')
#+END_SRC

#+RESULTS:
: # Out [5]: 
: # output
: "Apples" < "Oranges" yields True
: 

In this case, python compares the ASCII value of the first letter in
each word, so this comparison is not particularly meaningful.

There are other more specialized functions, which allow you to test
whether a number is e.g., of type real or of type integer
@@latex:\index{functions!isinstance()} \index{isintance()!function}@@
#+BEGIN_SRC ipython
isinstance(12, int)
#+END_SRC

#+RESULTS:
: # Out [6]: 
: # text/plain
: : True

They also return boolean values.


** Logic Operators
 @@latex:\index{operators!logic} \index{logic operators}@@
Now that we have truth values (aka boolean values), we can use logic
operators to create more complex statements. Think, e.g., a condition
like this: The student will pass the class if he submits more than 70%
of his assignments, and is never more than 10 minutes late to
class. This requires that we combine two or more comparison
operators. There is indeed a whole subset of mathematics dedicated to
this (boolean algebra), but for our purpose, we get away with the 3
basic operators called =and=, =or=, and =not=.
#+BEGIN_EXAMPLE
A = True
B = False
A and B   # only true if both are true
A or  B   # true if at least one is true
A not B   # wrong syntax, see below
#+END_EXAMPLE

lets do an actual example
#+BEGIN_SRC ipython
x = 12

r = x > 0 # test if x is greater than 0
print(f"x > 0 = {r}")

r = x < 10 # test if x is smaller than 0
print(f"x < 10 = {r}")

r = x > 0 and x < 10 # test if x is bewteen 0 and 10
print(f"x > 0 and x < 10 = {r}")

r = x > 0 or x < 10 # test if x is either larger than 0 or smaller than 10
print(f"x > 0 or x < 10  = {r}")
#+END_SRC

#+RESULTS:
: # Out [2]: 
: # output
: x > 0 = True
: x < 10 = False
: x > 0 and x < 10 = False
: x > 0 or x < 10  = True
: 

You can see that the above can get messy pretty quickly. Things get
even more complicated if we start using the =not= operator. Imagine we
need a statement which tests whether =x= falls in between a certain
range (3^{rd} expression above). We can write this using the =not=
operator as

#+BEGIN_SRC ipython
x = 12
r = not(x > 0 and x < 10) # test if x is not bewteen 0 and 10
print(f"not(x > 0 and x < 10) = {r}")
#+END_SRC

#+RESULTS:
: # Out [3]: 
: # output
: not(x > 0 and x < 10) = True
: 

However, with a little bit of thinking we can rewrite this as
#+BEGIN_SRC ipython
x = 12
r = x <= 0 or x >= 10 # test if x is smaller than 0 and larger than 10
print(f"x < 0 and x > 10 = {r}")
#+END_SRC

#+RESULTS:
: # Out [4]: 
: # output
: x < 0 and x > 10 = True
: 

which may be easier to read.

Note that it makes a difference whether you write =x > 4= or =not(x <
4)=. The former includes 5, whereas the latter statement also includes
the number 4. So care must be taken when negating (or un-negating)
statements. Use the following snippet to test whether both statements
give the same result for various values of =x=.
#+BEGIN_SRC ipython
x = 12
print(f"x = {x}")
r = x > 0 or x < 10 # test if x is either larger than 0 or smaller than 10
print(f"x > 0 or x < 10  = {r}")

r = not(x >= 0 or x <= 10) # test if x is either larger than 0 or smaller than 10
print(f"not(x >= 0 or x <= 10)  = {r}")
#+END_SRC

#+RESULTS:
: # Out [5]: 
: # output
: x = 12
: x > 0 or x < 10  = True
: not(x >= 0 or x <= 10)  = False
: 

This becomes even more tricky when you use the =or= statement. The
first logic operation in the next cell is obviously true
#+BEGIN_SRC ipython
x = 12
print(f"x = {x}")

r = x > 0 or x < 10 # test if x is either larger than 0 or smaller than 10
print(f"x > 0 or x < 10  = {r}")

# If we negate the above in english, we would get:
# test if x is neither larger/equal than 0  or smaller/equal than 10
# however, that is not what this code does
r = not(x >= 0 or x <= 10)
print(f"not(x >= 0 or x <= 10)  = {r}")

# rather, it says :  not(x is either larger than 0 or smaller than 10).
# to get the English language version, you would have to write

r = not(x >= 0) or not(x <= 10)
print(f"not(x >= 0) or not(x <= 10)  = {r}")
#+END_SRC

#+RESULTS:
: # Out [6]: 
: # output
: x = 12
: x > 0 or x < 10  = True
: not(x >= 0 or x <= 10)  = False
: not(x >= 0) or not(x <= 10)  = True
: 

The second statement is obviously the not-version of the first (so
=True= becomes =False= or vice versa), but it is not how we would
negate a statement in English.

Only the third statement is equivalent to the English language
meaning. Much confusion and incorrect code originates from the careless
writing of logical expressions. Towards this end, I am a great fan of using brackets to clarify logic operations. Consider this example
#+BEGIN_SRC ipython
r = not(x >= 0 or x <= 10)
# versus
r = not(
    x >= 0
    or
    x <= 10
)
# or
r = not(
    (x >= 0) or (x <= 10)
)
#+END_SRC

Space comes for free, deciphering code costs time....

Use the above snippet to test whether these expressions indeed give
the same results for various values of x. Also, note the use of the
brackets to group statements and the absence of commas. Otherwise,
you would create a tuple.

