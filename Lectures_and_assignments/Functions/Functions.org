#+STARTUP: showall
#+OPTIONS: todo:nil tasks:nil tags:nil toc:nil
#+PROPERTY: header-args :eval never-export
#+PROPERTY: header-args :results output pp replace
#+EXCLUDE_TAGS: noexport
#+LATEX_HEADER: \usepackage{breakurl}
#+LATEX_HEADER: \usepackage{newuli}
#+LATEX_HEADER: \usepackage{uli-german-paragraphs}



* Functions
@@latex:\index{functions}@@ Another way to group lines of code into blocks, is
to use functions. Functions have two main characteristics:

  1) They allow us to group code sequences and refer to this group by
     name. This useful to declutter your code, and is particularly
     useful if certain code sections have to be executed again and
     again. In fact, most of the python statements we have used so
     far, are simply functions which we call by name (e.g., the print
     statement).
  2) Functions allow us to isolate code sections from each other. In
     other words, whatever happens inside of a function remains there
     until you explicitly share it with the rest of your
     code. Consider the case of the print function and some variable
     =i= which you use in your code. It may very well be that the
     print function uses some code which involves a variable
     =i=. However, this would never affect the value of your variable
     =i=, nor would your variable =i= affect the value of =i= inside
     the print function. So functions allow you to separate code
     pieces from each other. @@latex:\index{functions!variable
     scope}@@ The technical term would be that they limit the scope of
     a variable.

We can thus use functions to extend the capabilities of our
program. We could for example create a function called =cube= which
will calculate the cube of a number (see below). Since everything
inside a function is isolated from everything outside a function, we
need way to pass values to and fro.


The *value(s)* of a variable(s) can be passed into a function as
arguments to the function call (see below)
@@latex:\index{functions!argument}@@. Since we only pass the value to
the function, we need to assign this value to a new variable inside
the function. 

For the same reason, the result of the code inside the function must
be returned to the calling code with a return
statement. @@latex:\index{functions!return value}@@. 

Note, that functions must always be defined before you can use
them. This is best done at the beginning of the code



** Examples 
The behavior of functions is easier explored than explained. 
#+BEGIN_SRC ipython
def my_cube(v): 
    r = v * v * v
    return r

# now for our regular code
x = 12
xc = my_cube(x)
print(xc)
#+END_SRC

#+RESULTS:
: # Out [2]: 
: # output
: 1728
: 

The first line defines the name of the function ("cube") and the name
of the lone argument to the function, and you already know the colon
which starts a new block statement. Note that the name (=v=) is only
used inside the function and that the name of the variable in the call
to =my_cube= is =x=. We could in fact simply write =my_cube(12)= and
we would get the same result. Also, try to access the value of r
outside of the function:
#+BEGIN_SRC ipython
def my_cube(v): 
    r = v * v * v
    return r

# now for our regular code
x = 12
xc = my_cube(x)
print(xc)
print(r)
#+END_SRC

#+RESULTS:
#+begin_example
# Out [3]: 
# output

NameErrorTraceback (most recent call last)
<ipython-input-3-dce1ea84cab5> in <module>
      7 xc = my_cube(x)
      8 print(xc)
----> 9 print(r)

NameError: name 'r' is not defined
#+end_example
This will fail, because =r= only exists inside the function, not
outside.

It is a good idea to add some explanation of what your function
does. This is done with a doc string. You can display the doc-string
with the help function:

#+BEGIN_SRC ipython
def my_cube(v):
    """This function takes a single numeric value (v) and return its cube (r)
    """
    r = v * v * v
    return r

help(cube)
#+END_SRC

#+RESULTS:
: # Out [5]: 
: # output
: Help on function cube in module __main__:
: 
: cube(v)
:     This function calculates the cubed value of v. v must be a single
:     numeric value
: 
: 


It is another good idea to specify the type of each variable. This
 makes it much easier to understand the code. This is done with so
called type hints.
#+BEGIN_SRC ipython
def my_cube(v:float)->float:
    """This function takes a single numeric value (v) and return its cube (r)
    """
    r :float = 0  # always good style to initialize each variable
    r = v * v * v 
    return r

x :float = 12.2 
print(cube(x))
#+END_SRC
So the first line states the function expects a float value as
argument, and that it will return float value to the calling program.
Note that these are merely hints. Python will not check that this is
actually true.

** Global versus local variables
So far, I claimed that the inside of a function knows nothing about
the outside. This is only half-true. Python knows so called global
variables @@latex:\index{variables!scope!global} \index{global
variables}@@. In fact, any variable which is know outside the
function, and has no explicit definition inside a function, is
considered global.

This code will work because =a= is only defined outside the
function. So in this case, =a= is a global variable
#+BEGIN_SRC ipython
# define function
def my_function():
    print(a)

# now lets use the function in our own code
a :int = 12
my_function()
#+END_SRC

#+RESULTS:
: # Out [1]: 
: # output
: 12
: 

If we were to define =a= locally inside the function, this definition
would not override the value of =a= outside the function.
#+BEGIN_SRC ipython
# define function
def my_function():
    a :str = "empty"
    print(f"a inside the function = {a}")
    
# now lets use the function in our own code
a :int= 12
my_function()
print(f"a outside the function = {a}")
#+END_SRC

#+RESULTS:
: # Out [2]: 
: # output
: a inside the function = empty
: a outside the function = 12
: 

So the mere fact that we declared =a= inside the function made it
local. In most cases, avoid using global variables like the pest. So a
good function always passes all the information as arguments, and
returns all the results. 





