#+STARTUP: showall
#+OPTIONS: todo:nil tasks:nil tags:nil toc:nil
#+PROPERTY: header-args :eval never-export
#+PROPERTY: header-args :results output pp replace
#+EXCLUDE_TAGS: noexport
#+LATEX_HEADER: \usepackage{breakurl}
#+LATEX_HEADER: \usepackage{newuli}
#+LATEX_HEADER: \usepackage{uli-german-paragraphs}



* Functions


@@latex:\index{functions}@@ In the previous module we used blocks of
programming statements so that we can execute them repeatedly (loop
statements) or based on a given condition (if statements).

Functions are another way to group program statements. However, unlike
ifs and loops, functions allow us the create named code blocks. This
allows us to write code which we can re-use in other programs.

Functions have the following characteristics:
  - They allow us to group code sequences and refer to this group by
    name. This is useful to declutter your code and is particularly
    helpful if individual code sections have to be executed again and
    again. Most of the python statements we have used so far, are
    simply functions (e.g., the print statement).
  - functions allow us to extend the capabilities of our program. We
    could, for example, create a function called =bprint= which will
    only print in bold.
  - Functions allow us to isolate code sections from each other. What
    happens inside the function, stays inside the function, and what
    happens outside the function, stays outside the function.
   @@latex:\index{functions!variable scope}@@
  - More to the point, functions provide a way to pass precisely
    defined information to the function, and return precisely defined
    result. So this greatly helps with program design, because we can
    divide a program into functional parts, which we can test and
    debug independently. In other words, we can reduce a complex
    problem into series of less complex problems.
  - the *value(s)* of a variable(s) can be passed into a function as
    arguments to the function call (see below)
    @@latex:\index{functions!argument}@@
  - The results of the computations inside the function can be
    returned to the calling code with the return
    statement. @@latex:\index{functions!return value}@@
  - Functions must always be defined before you can use them. This is
    best done at the beginning of the code

Think of the following problem: You want to write an application which
converts a mineral name into it's chemical formula. We can divide this
problem into the following functional parts:

  1. get user input
  2. interpret the user input and find chemical formula (or create an
     error message)
  3. provide the result to the user 

If we divide this problem with functions, we can write and test the
first part even if we have no idea what to do about number 2 & 3. The
same goes for #2, you can develop and test this, even so you are
completely ignorant about #1 (#3).

Now, consider you are working in a team. Likely, you would distribute
the tasks along the functional blocks. But this scenario also
highlight an interesting problem, you need to agree what kind of data
team #1 will provide to team #2, and what #2 will provide to #3. So
clearly, this requires a bit of planning, and more importantly good
documentation.

Let's do an actual example. We define a function with the =def=
keyword, followed by the function name and a pair of brackets() with
the usual colon symbol to denote the start of block
#+BEGIN_SRC ipython
def lookup_chemdata():
    # add your code here
    pass
#+END_SRC

the way this is written, this function would not know anything about
the data which exists outside the function. So let's write it in a way
that we pass on some data from the outside world. This is done by
adding one (or more) function arguments
#+BEGIN_SRC ipython
def lookup_chemdata(arg1):
    # add your code here
    pass
#+END_SRC

Can now call your function from a program, e.g.,
#+BEGIN_SRC ipython
lookup_chemdata("Barite")
#+END_SRC
So Barite would become the argument to the function, and inside the
function, this argument would be available through the variable
=arg1=. Note, the actual name does not matter. You could also write

#+BEGIN_SRC ipython
def lookup_chemdata(n):
    # add your code here
    pass
#+END_SRC
and then use =n= inside the function. So far our function does not
much, and most importantly, it does not pass any value back to the
calling program. So let's add a return statement
#+BEGIN_SRC ipython
def lookup_chemdata(n):
    if n == "Barite":
        f = "BaSO4"
    else:
        f = "Mineral not found"

    return f
#+END_SRC

#+RESULTS:
: # Out [1]: 

now you can call the function like this
#+BEGIN_SRC ipython
r = lookup_chemdata("Barite")
print(r)
#+END_SRC

#+RESULTS:
: # Out [2]: 
: # output
: BaSO4
: 

and the result of the function will be stored inthe variable to the
left of the equation sign (i.e., =r=). So far so good, however, what
is missing is some documentation on what the function does, and some
documentation on what type of data the function expects and returns.

*** Docstrings

The first problem is elegantly solved by adding a doc-string
@@latex:\index{docstring}, \index{functions!docstring}@@. A docstring
simply is a piece of explanatory text which we add at the beginning of
the function definition. Unlike a regular comment, we enclose this
text with three quotation marks
#+BEGIN_SRC ipython
def lookup_chemdata(n):
    """This function takes a mineral name, and returns its respective
    chemical formula. If the mineral name cannot be found, the
    function will return an error message.

    Example:

          f = lookup_chemdata("Barite")
    """
    if n == "Barite":
        f = "BaSO4"

    return f
#+END_SRC

#+RESULTS:
: # Out [3]: 

and now we use the python help system to find out what this function does
#+BEGIN_SRC ipython
help(lookup_chemdata)
#+END_SRC

#+RESULTS:
#+begin_example
# Out [4]: 
# output
Help on function lookup_chemdata in module __main__:

lookup_chemdata(n)
    This function takes a mineral name, and returns its respective
    chemical formula. If the mineral name cannot be found, the
    function will return an error message.
    
    Example:
    
          f = lookup_chemdata("Barite")


#+end_example
Much better! Note that comments are meant for people who read your
code, while docstrings are meant for people who use your code. To read
all about docstrings, see this link:

 https://realpython.com/documenting-python-code/

However, what is still missing is some information for
our fellow coders what type of data the function is expecting, and
what it will return to the calling code. We could (and some people
do), explain all this in the doc-string. But python provides a more
compact and elegant way.

*** Type hinting
@@latex:\index{type hinting}@@ Unlike many other computing languages,
python does not force you to declare that variable is of type integer,
or float. However, nothing prevents us to annotate our variable to
clarify what we mean (this works for python 3.5 and higher)

#+BEGIN_SRC ipython
a = 12       # an integer value
a: int = 12  # much faster to type
#+END_SRC
so in this example, we added a colon after the variable name, and then
used the keyword =int= to document that =a= should be an integer
value. Python provides the following keywords for its basic data
types
#+BEGIN_SRC ipython
a: int
b: float
g: list
h: dict
k: set
m: tuple
t: str
#+END_SRC
We can use this syntax to annotate our function, and now reading the
code it is more obvious what you are trying to do. Python provides
more type hinting support if we import the typing module
#+BEGIN_SRC ipython
from typing import Dict, Tuple
# instead of
d: dict = {"value", 12}
t: tuple = (2, 3)
# we can be even mor explicit 
d: Dict[str, float] = {"value", 12}
t: Tuple[int, int] = (2, 3)
#+END_SRC
but back to our original problem of documenting a function:

#+BEGIN_SRC ipython
def lookup_chemdata(n: str) -> str:
    """This function takes a mineral name, and returns its respective
    chemical formula. If the mineral name cannot be found, the
    function will return an error message.
    
    Arguments: lookup_chemdata(n: str) -> str:

    Example:

          f = lookup_chemdata("Barite")
    """
    if n == "Barite":
        f = "BaSO4"

    return f
#+END_SRC
Now, it is obvious that the function expects a string, and will return a string. 

  - *From now on, we will use this template for each and every
    function we create*
    
  - *From now on, we will use type hinting in all of our scripts and
    programs*
  - [[https://dropbox.tech/application/our-journey-to-type-checking-4-million-lines-of-python][If you want to read more on why type hinting is essential, read
    the story on Dropbox (which is written in python)]]
  

last but not least, let's make our function working in a more
practical way. Python dictionaries provide us with an elegant way to
create our lookup function:
#+BEGIN_SRC ipython
def lookup_chemdata(key: str) -> str:
    """This function takes a mineral name, and returns its respective
    chemical formula. If the mineral name cannot be found, the
    function will return an error message.
    
    Arguments: lookup_chemdata(n: str) -> str:

    Example:

          f = lookup_chemdata("Barite")
    """
    from typing import Dict  #  type hinting support for dictionaries

    # build our database
    database: Dict[str, str] = {
        'Barite': 'BaSO4',
        'Pyrite': 'FeS2',
    }

    # test if key is known in database
    if key in database:
        value = database[key]
    else:  # return an error message
        value = f"{key} is not in the database. Typo?"
    return value
#+END_SRC
This is a nice example of what you can do with a dictionary (test it
out by calling =lookup_chemdata= with various values. Note that we
import here some support for improved type hinting from the =typing=
module. More on this below.

** Functions and variable scope
Earlier we talked about how functions allow us to isolate code. So
let's explore this in more detail. Before running the following code,
take a moment to predict it's outcome
#+BEGIN_SRC ipython
# define function
""" test function. It returns nothing
"""
def my_function()-> None:
    a = a + 2

# now lets use the function in our own code
a :int = 12
my_function()
print(a)
#+END_SRC

#+RESULTS:
#+begin_example
# Out [6]: 
# output

UnboundLocalErrorTraceback (most recent call last)
<ipython-input-6-db179349f4a6> in <module>
      7 # now lets use the function in our own code
      8 a :int = 12
----> 9 my_function()
     10 print(a)

<ipython-input-6-db179349f4a6> in my_function()
      3 """
      4 def my_function()-> None:
----> 5     a = a + 2
      6 
      7 # now lets use the function in our own code

UnboundLocalError: local variable 'a' referenced before assignment
#+end_example
Uggh, the dreaded "UnboundLocalError". So what it really means, is
that you used variable a in line 5 before you actually defined
it. This happens, because =a= was assigned the value of twelve,
outside the function, and the function has no access to the values
outside. 

Conversely, whatever you define inside the function is not available
outside the function:
#+BEGIN_SRC ipython
# define function
""" test function. It returns nothing
"""
def my_function()-> None:
    b: int = 12
    b = b + 2

# now lets use the function in our own code
my_function()
print(b)
#+END_SRC

#+RESULTS:
#+begin_example
# Out [8]: 
# output

NameErrorTraceback (most recent call last)
<ipython-input-8-d2c987ead9c4> in <module>
      8 # now lets use the function in our own code
      9 my_function()
---> 10 print(b)

NameError: name 'b' is not defined
#+end_example


There are ways around this, by defining a variable as
=global=. However, this is really bad style and should be avoided like
the plague.


So let's implement our function the correct way:
#+BEGIN_SRC ipython
# define function
""" This function adds 2 to any number you pass to this function
"""
def my_function(c)-> int:
    c = c + 2
    return c

# now lets use the function in our own code
a: int = my_function(5)
print(a)
#+END_SRC

#+RESULTS:
: # Out [9]: 
: # output
: 7
: 


*** Function calls can be nested
@@latex:\index{functions!nesting}@@ The output of a function can be
used as the input to another function. You already know the print
function. So we can use the output of =my_function= as input to the
print function:
#+BEGIN_SRC ipython
a: int = 5
print(my_function(a))
print(f"adding 2 to {a} results in {my_function(a)}")
#+END_SRC


** Do's and do not's
As with all things code, there better ways, and there a ways to shoot
yourself into the foot. Here is a perfectly ok way to create a function
which changes capitalizes a string:
#+BEGIN_SRC ipython
def my_cap(s:str)-> None:
    """
    This function takes s:str and converts all characters to capitals
    """
    print(s.upper())

lc :str = "This is important"
my_cap(lc)
#+END_SRC

#+RESULTS:
: # Out [16]: 
: # output
: THIS IS IMPORTANT
: 

However, in almost all cases, a function should take one or more values,
and return one or more new values. So a better way of doing this would be
#+BEGIN_SRC ipython
def my_cap(s:str)->str:
    """
    This function takes s:str and converts all characters to capitals
    """
    return s.upper()

lc :str = "This is important"
print(my_cap(lc))
#+END_SRC

#+RESULTS:
: # Out [18]: 
: # output
: THIS IS IMPORTANT
: 

This solution is better because it separates the printing from the
conversion, and thus keeps =my_cap= fairly universal. We can now e.g., write
#+BEGIN_SRC ipython
ld :str = "--- this not so much"
print(my_cap(lc), ld)
#+END_SRC

#+RESULTS:
: # Out [21]: 
: # output
: THIS IS IMPORTANT --- this not so much
: 

You could achieve this with the previous definition as well, but it would
be more convoluted.

** Functions with multiple return values
@@latex:\index{functions!multiple return values}@@ There is nothing
special about functions which return more than one value. If you look
carefully, you see that the return argument is now a tuple.
#+BEGIN_SRC ipython
def foo(a: float) -> tuple():
    x = a
    y = a * 2
    return (x, y)


# code
v :float = 2
(k, l) = foo(v)
print(f"k = {k}, l = {l}")
#+END_SRC

#+RESULTS:
: # Out [17]: 
: # output
: k = 2, l = 4
: 

so multiple values are simply returned as a tuple. So how do we add
this information to our type hints? As of python 3.7, type hints are
only partially implemented. For the above case, we have first to load
an additional library, which defines type hinting for compound
datatypes. We will learn how to work with libraries in a later module,
for now, simply include the import statement at the beginning of your
code. @@latex:\index{type hinting!multiple return values}

#+BEGIN_SRC ipython
from typing import Tuple # import support for Tuple type hints

# define funnction foo
def foo (a:float)->Tuple[float,float]:
    x = a
    y = a * 2
    return (x,y)

# start of code
# define all variable we are using
v :float = 2
k :float
l :float
# call function foo
k, l = foo(v)

# print resulty
print(f"k = {k}, l = {l}")
#+END_SRC

#+RESULTS:
: # Out [8]: 
: # output
: k = 2, l = 4
: 



** Recursive functions
@@latex:\index{functions!recursive}@@ Functions can call itself. For
certain problem-sets, this can be a rather elegant way of
coding. However, python is not well suited to recursive programming -
so will not use it in our course. However, for good measure, it should
at least be mentioned. The following examples is a bit construed, but
demonstrates the principle.
#+BEGIN_SRC ipython
from typing import Tuple  # import support for Tuple type hints


def div2(n: float, c: int) -> Tuple[float, int]:
    """This function divides n by 2 and will do so until the result is
    smaller than 1. In other words, this function returns the number
    of times an integer value can be divided by two.

    """
    n = n / 2

    if n >= 1:
        c = c + 1
        (n, c) = div2(n, c)

    return (n, c)


# start of main code
x: float = 8
i: int = 0

nt: int
nb: float
nb, nt = div2(x, i)
print(f"{x} can be devided by two {nt} times")
#+END_SRC

#+RESULTS:
: # Out [54]: 
: # output
: 8 can be devided by two 3 times
: 


