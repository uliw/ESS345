#+STARTUP: showall
#+OPTIONS: todo:nil tasks:nil tags:nil toc:nil
#+PROPERTY: header-args :eval never-export
#+EXCLUDE_TAGS: noexport
#+LATEX_HEADER: \usepackage{breakurl}
#+LATEX_HEADER: \usepackage{newuli}
#+LATEX_HEADER: \usepackage{uli-german-paragraphs}


* Assignment

Functions have the following characteristics:
  - They allow us to group code sequences and refer to this group by
    name. This is useful to declutter your code.
  - Code which is grouped inside of a function does not have access to
    variables which are defined outside of a function.  This helps to
    isolate code sections and prevents naming conflicts or accidental
    overwriting of a, e.g., a counter.
  - the *value(s)* of a variable(s) can be passed into a function as
    arguments to the function call (see below)
  - The result of a computation inside the function can be
    returned to the calling code with the return statement.
  - Functions must always be defined before you can use them. This is
    best done at the beginning of the code

When solving this assignment, be strategic about it. You can probably
see that there are three independent challenges here:

 1) create functions
 2) embed the functions into a loop
 3) add data to an empty list.

Solve each problem individually, before you combine it into a more
complex program.
 
** Converting data from a Mass spectrometer into delta notation
Most elements have variations in their atomic structure, which affect
their weight, but not their chemical characteristics. In other words,
they have the same number of protons but a different number of
neutrons. You will likely have heard of oxygen or carbon isotopes,
both featuring prominently in the current climate change debate, and
isotopes feature prominently in almost all geoscience research. 


Stable isotopes are measured with a mass spectrometer where the oxygen
atoms are ionized, then accelerated, and the beam of accelerated ions
is then sent through a magnetic field, which will bend this beam. The
ions with additional neutrons, are heavier and thus will have a
different curve radius then the lighter ones (see
Fig. ref:fig:IRMS). Therefore we can split the beam into two beams. The two
beams will then be collected by Faraday cups, which count the number of
arriving ions (i.e., they register a voltage). Based on these
voltages, we can establish the ratio between these isotopes.

#+CAPTION: Schematic drawing of an isotope mass ratio monitoring mass spectrometer (IRMS).
#+CAPTION: Source: https://commons.wikimedia.org/wiki/File:Mass_Spectrometer_Schematic.svg, 2019
#+NAME: fig:IRMS
[[./Mass_Spectrometer_Schematic.png]]

Most geological processes change the isotope ratio of a given element
only by a  small fraction. Consider the following example, which
uses sulfur isotopes from seawater sulfate. Sulfur has 4 stable
isotopes (^{32}S, \nbsp{}^{33}S, \nbsp^{34}S, \nbsp{}^{36}S), and one unstable (i.e., radiogenic)
isotope (^{35}S). Here we will stick to the two most abundant isotopes
\nbsp{}^{32}S and \nbsp{}^{34}S. The following data is from actual measurements of
seawater sulfate.
#+BEGIN_SRC ipython
# remember that variable names cannot start with a number!
S32 :list = [0.956825467106151, 0.956824254162342, 0.956831127551253,
             0.956806868972346, 0.956808486172672, 0.95680282599545,
             0.957705256379378, 0.956814955028641, 0.957705256379378,
             0.957705256379378, 0.956929791779426, 0.957705256379378,
             0.957705256379378, 0.956975491533205, 0.957000163125976,
             0.956964976158995]

S34 :list = [0.043174532893849, 0.043175745837658, 0.043168872448747,
             0.043193131027654, 0.043191513827328, 0.04319717400455,
             0.042294743620622, 0.043185044971359, 0.042294743620622,
             0.042294743620622, 0.043070208220574, 0.042294743620622,
             0.042294743620622, 0.043024508466795, 0.042999836874024,
             0.043035023841005]


#+END_SRC

#+RESULTS:
:results:
# Out [1]: 
:end:

From the above, you can see that there is a lot more S^{32} than there is S^{34}. 
You can also see that if we only look at the ratios between S^{32}and S^{34}, the
numbers are unwieldy and it is hard to spot the change between two
values. I.e.,
#+BEGIN_SRC ipython
print(f"34S/32S [0] = {S34[0]/S32[0]}")
print(f"34S/32S [4] = {S34[4]/S32[4]}")
#+END_SRC

It is therefore customary to express the change in isotope ratio as a
difference relative to a standard value. The unit of the delta notation is
"per mil" which translates as "per thousand" (or 0.1 %)

\begin{equation}
\delta^{34}S = \left(
       \frac{
         \left(\frac{34S}{32S}\right) _{Sample}}
       {
         \left(\frac{34S}{32S}\right) _{VCDT}}
       -1
       \right) \times 1000 \quad [^0/_{00}]
\end{equation}

For sulfur, the standard value is a meteorite, the Canyon Diabolo
Troilite. Since this standard has long been depleted, we nowadays use
a virtual value, the so-called "Vienna Canyon Diabolo Troilite"
(VCDT). The reference ratio of \nbsp^{34}S/^{32}S  for VCDT is
#+BEGIN_SRC ipython
R :float = 0.044162589 # Reference ratio of 34S/32S for VCDT
#+END_SRC


** Question 1
Create a function which takes two numbers as argument (say a S32[i], and
 S34[i]) and returns the respective delta back to the calling program.
 To keep the function universal, also pass the reference ratio as
 argument. So your function interface will look like this
#+BEGIN_SRC ipython
def v2d (li :float, hi:float, R:float) -> float:
#+END_SRC
where =li= stands for 'light isotope' and =hi= stands for 'heavy isotope'
*Note, =li= and =hi= must be single values, not a complete list.*

Embed this function into a loop which iterates of each element of
 =S32= and =S34= and then calls =v2d= for each isotope pair. Store the
 returned delta value in the new list =delta=, print out the results
 of your conversion according to the below template, before starting
 the next iteration.
 #+BEGIN_EXAMPLE
 S34 = and  S32= yield a delta value of = XX.XX permil
 #+END_EXAMPLE
Note the explicit print format for delta. Also, remember that the
print statement should be in your main code, not inside your function

On order to solve this assignment, you will have to create a new (and
empty) and then append the results to this list. The following code
snippet will be helpful for this. See the previous module on lists if
you do not recall how to append data onto a list
#+BEGIN_SRC ipython
delta: list = [] # this will create and empty list
delta: list = list() # this will do the same

# or of you import the List type from typing
delta: List[float] = []
#+END_SRC
The goal with this exercise is to make you think about function
arguments, how to use multiple arguments, and how to go from an
equation to a function.

Before you go ahead and start coding consider the following:

 - Does the assignment ask to pass the list to the function, or an
   individual value. Look at the type hints in the above function definition.
 - What step do you need to take in order to solve this
   assignment. Write this down without worrying how to do this in python. Your notes could look like this:
   - Define v2d and test that values are being computed as intended
   - Declare an empty which will hold my results
   - Loop over all list elements
     - Access the individual list elements by index
     - Call =v2d(list1[i],list2[i])= for each list element
     - append the result to the empty list created above

Each of the techniques has been use before. If need be, make good use of the textbook, and test each step before going to the next one

** Question 2
We can invert the above equation and calculate the respective isotope
concentrations from the delta value we stored in =delta= (lets call
this function d2i). In order to keep the function universal, I will
call the respective isotopes simply =li= for 'light isotope' and =hi=
for 'heavy isotope'
\begin{equation}
    li = \frac{1000}{(\delta +1000) \times R + 1000}
\end{equation}
\begin{equation}
    hi = \frac{(\delta + 1000) \times R}{(\delta + 1000) \times R + 1000}        
\end{equation}
write a function which will take a delta value and returns the light
and heavy isotope values. Then write some code which will use a loop
to iterate over each delta value in the =delta= list, and call your
function to compute the light and heavy isotopes.  Store the returned
values in the new lists =S32_new= and =S34_new=.

** Question 3

Use a single loop to compute the element by element difference between
=S32= and =S32_new=. Within the same loop, do the same for =S34= and
=S34_new=. Also keep a running tally of the total accumulated error
\begin{equation}
    err_{S32} = \sum err_{S32} (i)
\end{equation}
Do this for both, =S34= and =S32=

Your total error should be a really small number (i.e., 1^{-16} etc).


** Marking Scheme

- Your code uses the correctly defined functions (docstrings, and
  type-hinting, parameters) 2 * 3 = 6 pts
- Your code calculates the requested quantities 3 * 2 = 6 pts.

Notes: As usual, create a notebook in your submissions folder named
=FirstName_LastName_functions.ipynb=, and submit the pdf and notebook on
Quercus

