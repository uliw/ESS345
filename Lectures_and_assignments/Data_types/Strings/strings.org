#+STARTUP: showall
#+OPTIONS: todo:nil tasks:nil tags:nil toc:nil
#+OPTIONS: d:(not "results")
#+PROPERTY: header-args :eval never-export
#+PROPERTY: header-args :results output pp replace
#+EXCLUDE_TAGS: noexport
#+LATEX_HEADER: \usepackage{breakurl}
#+LATEX_HEADER: \usepackage{newuli}
#+LATEX_HEADER: \usepackage{uli-german-paragraphs}





* Strings
@@latex:\index{strings} \index{characters!storing}@@
@@latex:\index{variable!type!strings}@@ Previously, we explored how
numbers are stored in memory. This was achieved by changing a number
from its representation in the decimal system to the binary system.

There is no simple way to do the same for letters
@@latex:\index{letters}@@ and symbols
@@latex:\index{symbols}@@. However, nothing prevents us from mapping
letters to numbers and then storing the number. The only extra step
required is to tell the program that this number is meant to be a
letter. Python will then use a lookup table to figure out which letter
to print as output. Obviously, this will only work if everyone agrees
to use the same lookup-table...

We can use the =chr()= function to show the character associated with
a given number  @@latex:\index{functions!char()} \index{ASCII}@@ \index{number to
ASCII}
#+BEGIN_SRC ipython
print(chr(65))
#+END_SRC

#+RESULTS:
: # Out [1]: 
: # output
: A
: 

But how do we tell python that a given value should be interpreted as
a character? Using =chr()= each time we would like to see a character
would be pretty tedious.

In our last module, we discovered that each variable is assigned a
type (int, float, etc.). These assignments are done when you assign a
value to the variable. E.g., if you type =a=12= python will assign an
integer-type. If you type =a=12.1= python will assign an float-type.

However, we can't simply write =a=b= to assign the letter =b= to the
variable a, because b could also be the name of a variable. Most
programming languages thus use quotation marks to indicate that you
are assigning a character to a variable. Consider the following
#+BEGIN_SRC ipython
b = 12     # the value of the variable b is 12
print(b)
a = b      # the value of the variable a is 12
print(a)
a = "b"    # the value of the variable a is the letter b
print(a)
print("a") # print the character "a"
#+END_SRC

#+RESULTS:
: # Out [2]: 
: # output
: 12
: 12
: b
: a
: 

you can use either single quotation marks or double ones
#+BEGIN_SRC ipython
a = 'b'  # OK
print(a)
a = "b"  # OK
print(a)
#+END_SRC

#+RESULTS:
: # Out [3]: 
: # output
: b
: b
: 

but this will not work
#+BEGIN_SRC ipython
a = "a'
#+END_SRC

#+RESULTS:
: # Out [4]: 
: # output
:   File "<ipython-input-4-f49d06fb6a41>", line 1
:     a = "a'
:            ^
: SyntaxError: EOL while scanning string literal
: 

Lastly, We can use the =ord()= function to show which number belongs
to a given letter  @@latex:\index{functions!ord()}@@ \index{ASCII to
number}
#+BEGIN_SRC ipython
print(ord("a"))
#+END_SRC

#+RESULTS:
: # Out [5]: 
: # output
: 97
: 


** The ASCII table
 @@latex:\index{ASCII table}@@ ASCII stands for "American Standard Code for
Information Interchange" and defines a way to map characters to
numbers (see the below table for a short excerpt).

| Dec | Hex | Char | Description |
|-----+-----+------+-------------|
|  <> |  <> | <>   | <>          |
|  65 |  41 | A    | Capital A   |
|  66 |  42 | B    | Capital B   |
|  67 |  43 | C    | Capital C   |
|  68 |  44 | D    | Capital D   |
|  69 |  45 | E    | Capital E   |
|  70 |  46 | F    | Capital F   |
|  71 |  47 | G    | Capital G   |
|  72 |  48 | H    | Capital H   |
|  73 |  49 | I    | Capital I   |

The full table is available at [[https://en.wikipedia.org/wiki/ASCII][https://en.wikipedia.org/wiki/ASCII]] The
ASCII standard is the oldest and most widely accepted way to map
characters to numbers. However, due to its age and country of origin,
it comes with considerable limitations. It was originally designed to
store text characters with a bit-width of 1 byte. I.e., with numbers
between 0 and 255. This implies that there are not enough mappings to
considers special characters, like umlauts, let alone other alphabets.

 @@latex:\index{unicode}@@ It is only recently that a globally accepted mapping
between numbers and text has become available
([[https://en.wikipedia.org/wiki/Unicode][https://en.wikipedia.org/wiki/Unicode]]), but even there, different
variants exists, and not every operating system supports them in the
same way. This is one of the reasons why we will only use letters
which are defined in the original ASCII-table.

** Strings
@@latex:\index{strings} \index{variable!types!string}@@ Working with
single letters is not convenient. Thus, every computer languages knows
about sequences of letters, which are called strings. We can think of
strings simply as a special type of list. It should, therefore, be no
problem for you to print, e.g., the 3^{rd} letter of this string.

#+BEGIN_SRC ipython
a = "This is an example of a string"
print(a)
# now print the 3rd letter of this string
#+END_SRC

#+RESULTS:
: # Out [6]: 
: # output
: This is an example of a string
: 

Unlike lists, you cannot modify elements of a string (i.e., they are immutable):
#+BEGIN_SRC ipython
a = "Joe"
a = "Jessie" # this is ok
a[2] = "x"   # this is not
#+END_SRC

#+RESULTS:
#+begin_example
# Out [1]: 
# output

TypeErrorTraceback (most recent call last)
<ipython-input-1-b0243790d60c> in <module>
      1 a = "Joe"
      2 a = "Jessie" # this is ok
----> 3 a[2] = "x"   # this is not

TypeError: 'str' object does not support item assignment
#+end_example

Similarly to lists, you can work with ranges, and you can query a
string object to see which methods it provides.


