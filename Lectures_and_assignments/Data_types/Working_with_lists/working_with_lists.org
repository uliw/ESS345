#+STARTUP: showall
#+OPTIONS: todo:nil tasks:nil tags:nil toc:nil
#+OPTIONS: d:(not "results")
#+PROPERTY: header-args :eval never-export
#+PROPERTY: header-args :results output pp replace
#+EXCLUDE_TAGS: noexport
#+LATEX_HEADER: \usepackage{breakurl}
#+LATEX_HEADER: \usepackage{newuli}
#+LATEX_HEADER: \usepackage{uli-german-paragraphs}

** TODO Add list addition

* Working with lists

Slicing lists is all good fun, but to work with lists, we
need meaningful ways to modify it. The following code is
straightforward to understand
#+BEGIN_SRC ipython
my_list = [1, 2, 3]
print(my_list)
my_list[1] = 44
print(my_list)
#+END_SRC

#+RESULTS:
: # Out [1]: 
: # output
: [1, 2, 3]
: [1, 44, 3]
: 


I also assume that it is clear what I am trying to do in this example
#+BEGIN_SRC ipython
my_list = [1, 2, 3]
my_second_list = my_list
#+END_SRC

#+RESULTS:
: # Out [2]: 


but explain the following:
#+BEGIN_SRC ipython
my_list = [1, 2, 3]
my_second_list = my_list
my_list[1] = 44
print(my_second_list)
#+END_SRC

#+RESULTS:
: # Out [3]: 
: # output
: [1, 44, 3]
: 


To understand this result, we need to make a detour into what
lists actually are, and how python handles them.


** A quick detour into the world of object-oriented programming (OOP)
There are several ideas how to best represent a real world problem in
terms of a program. The two most prominent approaches are functional
programming, and object oriented programming.

In a functional program, we have self contained program code which
expects input data, then does it's thing, and returns output data. The
python function =len()= is a good example. In the following, I pass
the list =my_list= as an argument to the function=len()= which then
determines the length of the list =my_list=, and returns the length of =my_list= as a
numeric value which we can store in =l=
#+BEGIN_SRC ipython
my_list = [6,2,1]
l = len(my_list)
print(l)
#+END_SRC

#+RESULTS:
: # Out [3]: 
: # output
: 3
: 

This approach is very straight forward and clean (and what we will be
using for this course)

The other programming paradigm, is called object oriented
programming. In this case a set of self contained code, not only
contains instructions of how to modify data, but it also contains the
data.  @@latex:\index{object!oriented programming}@@.  While python
allows for both programming styles, the actual python language itself
is written object oriented code. So far, we considered =my_list= just
a special type of variable. It is however much more. =my_list= is in
fact list-object, which contains the list-data, but also knows several
methods to manipulate this data.

So, if you want to sort the data using the functional approach, we could write
#+BEGIN_SRC ipython
my_sorted_list = sorted(my_list)
print(my_sorted_list)
#+END_SRC

#+RESULTS:
: # Out [4]: 
: # output
: [1, 2, 6]
: 

Again, we pass =my_list= as argument to the =sort()= function, which
will return the a sorted list which we then can store in
=my_sorted_list=

Now let's do this the object oriented way.
#+BEGIN_SRC ipython
my_list.sort()
print(my_list)
#+END_SRC

#+RESULTS:
: # Out [5]: 
: # output
: [1, 2, 6]
: 

Here, we call the =sort()= method of the list-object, which will then
sort the list. Nice and compact, but now, we have modified the actual
list, whereas in the functional example, the original data was left
untouched.

We can explore what methods @@latex:\index{object!methods}@@
 @@latex:\index{python!functions!dir()} \index{functions!dir()}@@ are known to a
 given object.  Try the following:
#+BEGIN_SRC ipython
dir(my_list)
#+END_SRC

#+RESULTS:
#+begin_example
# Out [11]: 
# text/plain
: ['__add__',
:  '__class__',
:  '__contains__',
:  '__delattr__',
:  '__delitem__',
:  '__dir__',
:  '__doc__',
:  '__eq__',
:  '__format__',
:  '__ge__',
:  '__getattribute__',
:  '__getitem__',
:  '__gt__',
:  '__hash__',
:  '__iadd__',
:  '__imul__',
:  '__init__',
:  '__init_subclass__',
:  '__iter__',
:  '__le__',
:  '__len__',
:  '__lt__',
:  '__mul__',
:  '__ne__',
:  '__new__',
:  '__reduce__',
:  '__reduce_ex__',
:  '__repr__',
:  '__reversed__',
:  '__rmul__',
:  '__setattr__',
:  '__setitem__',
:  '__sizeof__',
:  '__str__',
:  '__subclasshook__',
:  'append',
:  'clear',
:  'copy',
:  'count',
:  'extend',
:  'index',
:  'insert',
:  'pop',
:  'remove',
:  'reverse',
:  'sort']
#+end_example

This will print a lengthy list of methods available with this
object. All the methods which start with a double underscore are meant
for internal use only (so-called "dunders"), all others are referred to as "user visible"  @@latex:\index{objects!methods!user visible}@@ @@latex:\index{user visible object methods}@@
 @@latex:\index{dunders}@@, so we
will not worry about them in this course. In our examples above, when
you call the list without anything, the =__str__= method is executed
and prints a string with the list data. And that is all you need to
know about double underscore methods (dunders).

How do we use these methods? Try this
#+BEGIN_SRC ipython
my_list  # this will activate the __str__ method
#+END_SRC

#+RESULTS:
: # Out [7]: 
: # text/plain
: : [1, 2, 6]

#+BEGIN_SRC ipython
## but we can also use it explicitly
my_list.__str__()
#+END_SRC

#+RESULTS:
: # Out [9]: 
: # text/plain
: : '[1, 2, 6]'

The results of both expressions are identical. Note, however, the use
of the brackets. Without this, the second example will fail (methods
like functions, always require brackets!)

More interesting (to us), are the methods which are meant to be used
by a user of this object (i.e., without underscores). If you check
the above, you will find a method called reverse. So let's try this. You
already noticed that we can call an object method by appending the
method name to the object. Also, for the sake of readability, I prefer
to explicitly call the print function as this makes it evident of what
you are trying todo. @@latex:\index{list!reverse}@@
#+BEGIN_SRC ipython
print(my_list)
my_list.reverse()
print(my_list)
#+END_SRC

#+RESULTS:
: # Out [7]: 
: # output
: [1, 44, 3]
: [3, 44, 1]
: 

Notice that the reverse method does not return the list values in
reversed order, rather, it reverses the list in place! @@latex:\index{list!sort}@@
#+BEGIN_SRC ipython
print(my_list)
my_list.sort()
print(my_list)
#+END_SRC

#+RESULTS:
: # Out [8]: 
: # output
: [3, 44, 1]
: [1, 3, 44]
: 

Since you may lose the original list,  sorting a list in place may, or
may not  be what you want!  See the above  example on how to  return a
sorted copy.


*Take me home:*
 - python objects consist of data and methods to manipulate the data
 - methods with a double underscore are not meant for external use
 - object methods are called by appending the method name with a dot
   to the object name (i.e., =my_list.sort()=).
 - Most object methods do not generate return values, rather they
   modify data in place.
 - functions are called by typing the function name and providing the
   argument to the function in brackets (i.e., =sorted(my_list)=)
 - most functions return a modified copy of the data which then needs
   to be stored in a new variable.


*** How to find out what those methods do


 @@latex:\index{help()} \index{getting help}
\index{functions!help()}@@ @@latex:\index{python!functions!help()}@@
But how do I know what all of these methods do? Thankfully, there is a
simple help system available: Let's try this with the sort method
#+BEGIN_SRC ipython
help(my_list.sort)
#+END_SRC

#+RESULTS:
: # Out [10]: 
: # output
: Help on built-in function sort:
: 
: sort(*, key=None, reverse=False) method of builtins.list instance
:     Stable sort *IN PLACE*.
: 
: 

Some gibberish here, but the key info is =Stable sort *IN PLACE*.=
which tells you that it will modify the actual list in place, and not
return a sorted copy. Contrast this with the output of
#+BEGIN_SRC ipython
help(sorted)
#+END_SRC

#+RESULTS:
#+begin_example
# Out [12]: 
# output
Help on built-in function sorted in module builtins:

sorted(iterable, /, *, key=None, reverse=False)
    Return a new list containing all items from the iterable in ascending order.
    
    A custom key function can be supplied to customize the sort order, and the
    reverse flag can be set to request the result in descending order.


#+end_example
which tells you that this function expects some sort of list (i.e.,
iterable), and will return a new list which is sorted.  If you are
still lost, use Google, and search for =python list sort=, which
likely directs you to =programiz= where you will find a clear
explanation and examples! And if this does not help, pipe up and get
in touch with your TA or instructor!
 

** Referencing objects
@@latex:\index{object!reference}@@ So most things python, are actually
objects which we can reference by name. The name in turn, is simply a
reference to a memory location where this object is stored. Thus,
=my_list= is merely an object handle, not the actual variable.  This
is why the following code does not produce the expected results:
#+BEGIN_SRC ipython
my_list = [1, 2, 3]       # create list object
my_second_list = my_list  # copy object handle
my_list[1] = 44           # use the copied object handle to modify a list element
print(my_second_list)
#+END_SRC

#+RESULTS:
: # Out [11]: 
: # output
: [1, 44, 3]
: 

@@latex:\index{object!copy}@@
So the second line does not produce a copy of the data in =my_list=,
rather, it copies the reference (i.e., the memory location of the list
object) to =my_list=. Let's verify this by querying python for the address of =my_list= and =my_second_list=
#+BEGIN_SRC ipython
print(id(my_list))
print(id(my_second_list))
#+END_SRC

#+RESULTS:
: # Out [12]: 
: # output
: 139631940633352
: 139631940633352
: 

as you can see, they are identical. So if we modify the content of
=my_second_list=, and then ask python to print the data at the memory
location =my_list= points to, we obviously get the very same data as
in =my_second_list=. Confused? You are in good company!

Python provides several methods around this problem, and as long as
you deal with simple lists that do not contain other lists, we can use
the =copy= method of the list object. This kind of copy is known as
shallow copy @@latex:\index{object!copy!shallow}. There is also a deep
copy \index{object!copy!deep}@@ function, but deep copies involve some
interesting problems which are beyond the scope of this course.
#+BEGIN_SRC ipython
my_list = [1, 2, 3]
my_second_list = my_list.copy()
my_list[1] = 44
print(my_list)
print(my_second_list)
#+END_SRC

#+RESULTS:
: # Out [13]: 
: # output
: [1, 44, 3]
: [1, 2, 3]
: 

*** Take me home

 - most things python are objects
 - objects are programming constructs which contain data and methods
   to manipulate the data.
 - you can query the object methods via =dir(object_name)=
 - you can call object methods via =object_name.method_name()=
 - object names are really just a handle to their memory location
 - copying the object handle, does not copy the data!
 - functions expect data as argument, and will return a copy of the
   processes data (aka result)

** Manipulating lists
@@latex:\index{manipulating!lists} \index{list!manipulating}@@ Back to our main
task. You have a list, and you want to append a value  @@latex:\index{lists!manipulating!append}@@
#+BEGIN_SRC ipython
my_list = [ 4, 2, 3]
my_list.append(1)
print(my_list)
#+END_SRC

#+RESULTS:
: # Out [14]: 
: # output
: [4, 2, 3, 1]
: 

lets, insert a new number at index position 2   @@latex:\index{lists!manipulating!insert}@@
#+BEGIN_SRC ipython
my_list.insert(1,44)
print(my_list)
#+END_SRC

#+RESULTS:
: # Out [15]: 
: # output
: [4, 44, 2, 3, 1]
: 

lets remove the last item on the list  @@latex:\index{lists!manipulating!remove element}@@
#+BEGIN_SRC ipython
my_list.pop()
print(my_list)
#+END_SRC

#+RESULTS:
: # Out [16]: 
: # output
: [4, 44, 2, 3]
: 

we can also be specific and remove the item at a given index
#+BEGIN_SRC ipython
my_list = [6,3,4,6,9]
my_list.pop(1)
print(my_list)
#+END_SRC

#+RESULTS:
: # Out [17]: 
: # output
: [6, 4, 6, 9]
: 

we can remove a value. Unlike =list.pop()= this will remove the first
occurrence of the number 6.
#+BEGIN_SRC ipython
print(my_list)
my_list.remove(6)
print(my_list)
#+END_SRC

#+RESULTS:
: # Out [18]: 
: # output
: [6, 4, 6, 9]
: [4, 6, 9]
: 

rather than adding a single value, we can add list of values
#+BEGIN_SRC ipython
my_list = [6,3,4,6,9]
my_list.extend([1,2,3])
print(my_list)
#+END_SRC

#+RESULTS:
: # Out [2]: 
: # output
: [6, 3, 4, 6, 9, 1, 2, 3]
: 

a variation of the above is when we have two lists which we can add together in the following way:
#+BEGIN_SRC ipython
second_list = [12, 16, 3, 0]
new_list = my_list + second_list
print(new_list)
#+END_SRC

#+RESULTS:
: # Out [9]: 
: # output
: [6, 3, 4, 6, 9, 1, 2, 3, 12, 16, 3, 0]
: 
Will the above also work for subtracting two list from each other?

We can find out at which index position we will find a given
value. For this you can use the =list.index()= method which will
return the first occurrence of a given value. Note, it will *only
return the first match!* We will explore how to find all matches in a
later chapter.
#+BEGIN_SRC ipython
print(my_list)
my_list.index(3)
#+END_SRC

#+RESULTS:
: # Out [3]: 
: # output
: [6, 3, 4, 6, 9, 1, 2, 3]
: 
: # text/plain
: : 1

we can count how many times a value occurs in the list
#+BEGIN_SRC ipython
print(my_list)
my_list.count(6)
#+END_SRC

#+RESULTS:
: # Out [20]: 
: # output
: [6, 3, 4, 6, 9, 1, 2, 3]
: 
: # text/plain
: : 2

and we can remove a value. *Note, that this will only remove the first
occurrence!*
#+BEGIN_SRC ipython
print(my_list)
my_list.remove(6)
print(my_list)
#+END_SRC


#+RESULTS:
: # Out [10]: 
: # output
: [6, 3, 4, 6, 9, 1, 2, 3]
: [3, 4, 6, 9, 1, 2, 3]
: 

and reverse a list (which is different than sorting!)  @@latex:\index{lists!manipulating!reverse}@@
#+BEGIN_SRC ipython
print(my_list)
my_list.reverse()
print(my_list)
#+END_SRC

#+RESULTS:
: # Out [22]: 
: # output
: [3, 4, 6, 9, 1, 2, 3]
: [3, 2, 1, 9, 6, 4, 3]
: 

sometimes it come in handy to know how many elements are in a
list. For this we can use the python function =len()=. Note how this
is a function, and not a list method. I.e., we call it by passing the
list as an argument to the function, rather then calling the list
method (i.e., =my_list.len()=)
#+BEGIN_SRC ipython
len(my_list)
#+END_SRC

#+RESULTS:
: # Out [17]: 
: # text/plain
: : 7

and for good measure, we can delete all list items
@@latex:\index{lists!manipulating!delete}@@
#+BEGIN_SRC ipython
print(my_list)
my_list.clear()
print(my_list)
#+END_SRC

#+RESULTS:
: # Out [23]: 
: # output
: [3, 2, 1, 9, 6, 4, 3]
: []
: 


** Take me home

   - There are numerous ways to manipulate lists:
     - You can join lists
     - You can add elements to a list at arbitrary positions
     - You can remove elements from a list
     - You can find out where elements are located in a list
     - You can count how often a value occurs in a list
     - You can count how many elements are in a list
     - You have practiced using methods which belong to the list
       objects (e.g., =list.pop()=, =list.index()= etc.), and using
       functions like =len(list)=
     - Many of the above methods will only return work with the first
       occurrence of a value. In a later chapter we will learn how we
       can use repetition to, e.g., get the index values of all
       occurrences.
