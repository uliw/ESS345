#+STARTUP: showall
#+OPTIONS: todo:nil tasks:nil tags:nil toc:nil
#+OPTIONS: d:(not "results")
#+PROPERTY: header-args :eval never-export
#+PROPERTY: header-args :results output pp replace
#+EXCLUDE_TAGS: noexport
#+EXCLUDE_TAGS: noexport
#+LATEX_HEADER: \usepackage{breakurl}
#+LATEX_HEADER: \usepackage{newuli}
#+LATEX_HEADER: \usepackage{uli-german-paragraphs}

* Lists

*Note 1:* This notebook contains several code blocks. The idea being that
you execute these code blocks as you read through the text. So treat
this notebook as an interactive tutorial, rather than a static
test. This mode of reading will be the default going forward.

*Note 2:* If you accidentally modify/delete notebook content, goto
=File= -> =Revert to Checkpoint=, and select the last a
checkpoint. The system should create a checkpoint the first time you
open a notebook. 

*Note 3:* Checkpoints are a powerful feature. When you work on your
assignments, create them ever so often, so that you do not lose your
work. It is good coding practice to create a new checkpoint whenever
you solved a minor milestone, and before you tackle the next problem.

@@latex:\index{variable!types!lists} \index{lists!variable type}@@ So
far, we only considered variables which hold a single value. However,
the true power of programming stems from the fact that you apply a
given procedure over and over. As such, python provides for a variety
of data-types @@latex:\index{data types}@@ which can hold more than
one value.

Lists basically hold a sequence of numbers. However, lists are not
restricted to numbers, they can contain numbers, letters, words, and
even other lists.  You can also mix and match these things in the same
list. For the sake of simplicity, we will stick to numbers here,
though.

Let's create a list: @@latex:\index{variable!type!list!create}
\index{list!create} \index{create!list}@@
#+BEGIN_SRC ipython
my_list = [1 2 3]
#+END_SRC


please execute this block.

ugh, this fails, you need to separate list items with commas!
#+BEGIN_SRC ipython
my_list = [1, 2, 3]
#+END_SRC

why is there no output?

The above statements assign values to a variable, however, the
assignment itself is not an operation that yields a result. All it
does, is to create a list. If you want to see the list, you need to
use the print function @@latex:\index{print function}@@ (we will
explore the print function in greater detail in a later chapter).
#+BEGIN_SRC ipython
my_list = [1, 2, 3]
print(my_list)
#+END_SRC


You may have noticed that in the previous modules, most variable names
were a single letter, whereas here I use a compound word. Personally,
I try to use a single letter or single words for simple variables
which only contain a single value, whereas compound variables use a
two letter name. You may also notice that I prefixed the variable with
the word =my=. This is simply to avoid potential overlap with builtin
python functions (e.g., =list()= which is a builtin function).

*** Take me home:

A summary of important concepts in the above chapter

 - You create lists by enclosing a sequence of numbers into square brackets
 - Individual list entries must be separated by a comma
 - Avoid the letters O, l, in variable names as they are easily
   confused with the numbers zero and one.
 - Avoid overwriting builtin python functions by prepending =my_= to
   your variable names. With time you will get the hang of it which
   names are being used by python(e.g., print, list, dict, float,
   etc.) and which names are save (e.g., =i=, =class_list= etc.).


** Accessing list elements

*** Single list elements
@@latex:\index{accessing!list!elements} \index{list!elements!access}@@
Consider the following list:
#+BEGIN_SRC ipython
my_list=[1.12, 3.2, 1.45, 12.01, 1.12, 3.2, 1.45, 12.01]
#+END_SRC

In real life, lists are often rather long, and we only want to see
certain elements of it. Say you only want to see the second element of
this list, so we can write
#+BEGIN_SRC ipython
print(my_list[1])
#+END_SRC


The number in the square bracket is called the index and refers to
position of the list element inside the list. Why do we see the 2^{nd}
element of this list, even so the index is =1=?

This is because python starts counting at zero. So to see the first
list element you would need to write =my_list[0]= (try this in the
above code cell for yourself). Most programming languages behave this
way (the notable exception is Matlab).

*** Accessing a range of elements (slicing)
@@latex:\index{slicing} \index{list!slicing}@@
@@latex:\index{variable!type!list!slicing}@@ If we want to see several
elements of a list (a so called slice), we can specify a range.
#+BEGIN_SRC ipython
print(my_list[2:4])
#+END_SRC


So rather than specifying a list index, we provide a range expression
=2:4= which you can read as =start:stop=. Compare the result of in
the above statement which the actual list. Which index positions are
actually retrieved by this operation. Do you understand why there are
only two values in the result? If you need to think about this for
more than 5 minutes, start talking to your peers, and if you still
can't figure it out, talk to TA or the instructor.

*** Accessing the last element(s) in a list

Sometimes, we have a-priory knowledge of how many list elements there
are, sometimes we don't. In this case We could use a python function
to query the length of a list (i.e., =len(my_list)=). However, we can
do this more elegantly with range expressions:
#+BEGIN_SRC ipython
print(my_list[-1])    # the last element in the list
print(my_list[-2])    # the second last
print(my_list[-3:-1]) # the third and second last!
print(my_list[-3:])   # the last 3
#+END_SRC


If you are really on the ball, you noticed that =-3:-1= and =-3:= give
different results, and you now know why (it is the same answer as in
the previous section). If this is still confusing, please find out
from your peers, and if this does not help, flag down a TA or the
instructor.

*** Other list slices
In the previous example, we have seen that the colon separates the
beginning and end values of a list range, and that if we omit the
number, it will default to the max index. The same is true for the
starting index
#+BEGIN_SRC ipython
print(my_list[0:3]) # will print the first 3 values
print(my_list[:3])  # this is the same
print(my_list[:])   # will print the whole list
#+END_SRC


last but not least, we can add a third argument to the range, to tell python to only access every n-th element (=start:stop:step-size=)
#+BEGIN_SRC ipython
print(my_list[0:-1:2]) # every second element  until the second last starting with the first
print(my_list[1::2])   # every second element including the last, starting with the second
#+END_SRC

and we can extend this to display the list in reverse. I.e., we
specify the higher index value as start value and the lower index
value as a stop value, and then we use a negative step size (this is
important!)

#+BEGIN_SRC ipython
print(my_list[-3:0:-1]) # start with the 3rd last element going  backwards to the 2n element
print(my_list[-3::-1])  # start with the 3rd last element going  backwards to the 1st element
print(my_list[-1::-1])  # Show the entire list backwards
print(my_list[::-1])    # Same but sthorter
#+END_SRC

If you do not understand why the first results omit the 1^{st} list
element, please speak up now.
