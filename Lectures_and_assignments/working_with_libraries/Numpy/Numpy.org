#+STARTUP: showall
#+OPTIONS: todo:nil tasks:nil tags:nil toc:nil
#+PROPERTY: header-args :eval never-export
#+PROPERTY: header-args :results output pp replace
#+EXCLUDE_TAGS: noexport
#+LATEX_HEADER: \usepackage{breakurl}
#+LATEX_HEADER: \usepackage{newuli}
#+LATEX_HEADER: \usepackage{uli-german-paragraphs}




* Numpy


@@latex:\index{numpy}@@ The numpy (numerical python) library provides
data types (and methods) to manipulate numerical data. If you have
used matlab before, you will be right at home, and if not, let's
explore numpy right here. Unlike lists, which can contain a sequence
of numbers, and all sorts of other things, numpy datatypes, can only
contain numbers. Furthermore, the numpy types typically carry a
specific meaning which enables us to use them to do linear algebra
(cross product, scalar product, matrix inversion, etc., etc.).

In the following, we will use this library for it's ability to
manipulate lists of numbers.  @@latex:\index{numpy!array}
\index{array!numpy}@@ The basic datatype in numpy, is the array. An
array has one or more dimensions. Another word for 1-dimensional array
is vector, and for a two-dimensional array is matrix.
@@latex:\index{numpy!vector}\index{numpy!matrix}@@
#+BEGIN_SRC ipython
import numpy as np

ml :list = range(0,10,1) # create a list
v :np.ndarray = np.array(ml)
print(v)
print(v[1])
print(type(v))
#+END_SRC

#+RESULTS:
: # Out [1]: 
: # output
: [0 1 2 3 4 5 6 7 8 9]
: 1
: <class 'numpy.ndarray'>
: 
In the above example, we first create a list, then we use =np.array()=
function to convert the list into a 1 dimensional array
(vector). Vector elements can be accessed by index similar to list
elements, and lastly we check that =v= is indeed a numpy object.

Numpy provides it's own functions to efficiently create lists of
numbers: @@latex:\index{numpy!zeros}\index{numpy!arange}\index{numpy!linspace}@@
#+BEGIN_SRC ipython
# get a list of zeros
print(np.zeros(5))         # vector of 5 zeros
print(np.arange(0,10,1))   # vector from 0 to 10 with step 1
print(np.linspace(0,9,10)) # vector from 0 to 9 with 10 elements
#+END_SRC

#+RESULTS:
: # Out [7]: 
: # output
: [0. 0. 0. 0. 0.]
: [0 1 2 3 4 5 6 7 8 9]
: [0. 1. 2. 3. 4. 5. 6. 7. 8. 9.]
: 

Arrays only contain numbers, and similar to a pandas dataseries, you
can do a lot of operations without the need of a loop Unlike pandas,
numpy arrays understand linear algebra, so you can do cross products,
matrix inversion, etc., etc.. But back to our main focus, manipulating
lists of numbers. Let's say you want to create a list of 10 X-Y
coordinates, where X runs from 0 to 1, with 11 entries, and Y runs
from 100 to 200 with 11 entries. So our desired array would then have
two columns and 10 rows. There are a couple of ways to achieve this,
but here we will use the =np.reshape()= function because this function
will be central to our assignment.
#+BEGIN_SRC ipython
X :np.array = np.linspace(0,1,5) # start, stop, number of elements
Y :np.array = np.linspace(100,200,5) # start, stop, number of elements
print(X)
print(Y)
#+END_SRC

#+RESULTS:
: # Out [11]: 
: # output
: [0.   0.25 0.5  0.75 1.  ]
: [100. 125. 150. 175. 200.]
: 
so for now, we two vectors, rather than a matrix. Now we combine both vectors
#+BEGIN_SRC ipython
XY np.ndarray = np.append(X,Y)
print(XY)
#+END_SRC

#+RESULTS:
: # Out [13]: 
: # output
: [  0.     0.25   0.5    0.75   1.   100.   125.   150.   175.   200.  ]
: 
ok, so we created a new 1-dimensional array =XY= which contains both
=X= and =Y=. But this is still not a list of coordinates - cue
=np.reshape()= @@latex:\index{numpy!reshape}@@ This commands allows us the change the geometry of an array
#+BEGIN_SRC ipython
m :np.ndarray = np.reshape(XY,(5,2))  # (# of rows, # of cols)
print(m)
#+END_SRC

#+RESULTS:
: # Out [21]: 
: # output
: [[  0.     0.25]
:  [  0.5    0.75]
:  [  1.   100.  ]
:  [125.   150.  ]
:  [175.   200.  ]]
: 

this gives us the correct geometry (5 rows, with elements each), but
the numbers are all mixed up. If this reminds you of the Rubiks cube,
you are on the right track. There is in fact a command to rotate to
rotate the matric elements, but before doing so, let's try something else
#+BEGIN_SRC ipython
m = np.reshape(XY,(2,5))  # (# of rows, # of cols)
print(m)
#+END_SRC

#+RESULTS:
: # Out [37]: 
: # output
: [[  0.     0.25   0.5    0.75   1.  ]
:  [100.   125.   150.   175.   200.  ]]
: 

just flipping the matrix dimensions in the reshape function, gives us
a matrix where the X and Y values are paired. Alas, the pairs are not
side by side, instead they are on top of each other. If you have
worked with excel before, you may have come across a function which
allows you to switch rows and columns, a transformation which is
called "transpose". Transposing a matrix is in fact such a common
operation that numpy provides a shorthand to do so. We just add the
=T= method to our matrix (note the absence of brackets after the =T=).
@@latex:\index{numpy!transpose}@@
#+BEGIN_SRC ipython
print("m befor transposing = \n")
print(m)
print("\n m after transposing = \n")
m = m.T
print(m)
#+END_SRC

#+RESULTS:
#+begin_example
# Out [38]: 
# output
m befor transposing = 

[[  0.     0.25   0.5    0.75   1.  ]
 [100.   125.   150.   175.   200.  ]]

 m after transposing = 

[[  0.   100.  ]
 [  0.25 125.  ]
 [  0.5  150.  ]
 [  0.75 175.  ]
 [  1.   200.  ]]

#+end_example


now , or matrix shows nicely paired X and Y values (compare this to
where we started with individual vectors).  If you look carefully, you
will see that each row is rendered as a list, and the matrix itself is
rendered as a list of lists. We access the individual matrix elements
in the usual index syntax. However, since we now have a 2-dimensional
array, we need two indices.
#+BEGIN_SRC ipython
print("get the second element in the second row:")
print(m[1,1]) # row 0, col 1

print("\n get all elements in the second row:")
print(m[1,:])

print("\n get all elements in the second column:")
print(m[:,1])
#+END_SRC

#+RESULTS:
#+begin_example
# Out [61]: 
# output
get the second element in the second row:
125.0

 get all elements in the second row:
[  0.25 125.  ]

 get all elements in the second column:
[100. 125. 150. 175. 200.]

#+end_example

Note that the last two print statements return 1-dimensional arrays
which are printed sideways. Unlike matlab, numpy does not
differentiate between row and column vectors. It is simply a 1-d
array, and those are always printed sideways.

There is a lot more to numpy, but the above will be enough to solve
our next assignment.
