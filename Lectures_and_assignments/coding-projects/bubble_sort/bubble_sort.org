#+STARTUP: showall
#+OPTIONS: todo:nil tasks:nil tags:nil toc:nil
#+PROPERTY: header-args :eval never-export
#+EXCLUDE_TAGS: noexport
#+LATEX_HEADER: \usepackage{breakurl}
#+LATEX_HEADER: \usepackage{newuli}
#+LATEX_HEADER: \usepackage{uli-german-paragraphs}


* Sorting a list 

There are many ways to sort a list of numbers. Some are fast, some
require plenty of memory, and most are pretty complex in order to be
fast without consuming to much memory. Here, we will use a slow, but
simple algorithm, the so called bubble sort. Consider the following
list of objects (imagine them as little towers with different heights,
where the number of stacked X's represents the height of the
towers). The characters at the bottom are the respective names of the
towers.
#+BEGIN_EXAMPLE
         X
         X X   X
       X X X X X
       X X X X X X
Name:  A B C D E F
#+END_EXAMPLE
In order to sort this list by height, we first compare the first and
second element (=A= & =B=). Since =A= is smaller than =B=, no action
is required. Next we compare the second and third element (=B= and
=C=). Since =B= is taller than =C=, it is clearly out of order. We can
rectify this by switching the order of =B= & =C= to =C= and =B=
#+BEGIN_EXAMPLE
           X
         X X   X
       X X X X X
       X X X X X X
Name:  A C B D E F
#+END_EXAMPLE
Next we continue with the third and fourth element. Clearly, =B= is
taller than =D=. So we swap positions again and get
#+BEGIN_EXAMPLE
             X
         X   X X
       X X X X X
       X X X X X X
Name:  A C D B E F
#+END_EXAMPLE
Now for the fourth and fifth element. Again, =B= is taller than
=E=. So we swap both
#+BEGIN_EXAMPLE
               X
         X   X X
       X X X X X
       X X X X X X
Name:  A C D E B F
#+END_EXAMPLE
and finally for the last two elements. Again, =B= is taller than
=F=. So we need to do another swap, and get
#+BEGIN_EXAMPLE
                 X
         X   X   X
       X X X X   X
       X X X X X X
Name:  A C D E F B
Index: 1 2 3 4 5 6
#+END_EXAMPLE
As you can see, this list is not fully sorted yet. All we achieved is
that the tallest tower has been moved to the end. This is however an
improvement over the original list. If we repeat this process, we will
move the second tallest tower to the right until it will be in front
of B. We can repeat this process until the list is fully sorted.

** How do I solve this?

In order to transform the above into computer code, lets first
consider what kind of decisions/actions have to be made in order to
sort the list:

 1. Do I want to panic or not? If yes, take a break and come back in
   10 minutes. If no, continue with #2

 2. What kind of list am I dealing with? Rather than using towers, we
    will use a list with numbers which we want sort in ascending order.

 3. What are the principal actions in the bubble sort method? A)
    Compare two elements of a list; B) Swap two elements of a list.

 4. Do I know how to compare two list elements? If no, go back to the
    working with lists exercise, if yes, can you do this for each list
    element? If no, go back to the chapter on loops. If yes, continue.
 5. Do I know how to swap two elements in a list? If no, see below.

Clearly, the keypart of this problem is to write a function which
swaps two elements of a list, and some code which decides if more
sorting is needed.


** How do I program this? 

The assignment is to write a program which will sort the following
list in ascending order:
#+BEGIN_SRC ipython
l :list = [1, 3, 2, 10, 3, 8, 7, 5, 6, 12, 11 ,4]
#+END_SRC


*** What are the program elements I need?
By now, you probably have some vague ideas how to solve this. Likely,
you will need a list of numbers, a loop which works through the list,
do some comparisons etc.. So what are the program elements you need?

 1. The list =l= (see above)
 2. A for loop and a counter =i= so that you can access each list
    element and the element to the right of this element (i.e., =l[i]=
    and =l[i+1]=).
 3. An if statement which decides whether =l[i] > l[i+1]= or not.
 4. A swap statement (see below)
 5. From the above, it is also clear, that you may have to repeat the
    bubble sort until the list is fully sorted. These kind of open
    ended operations are well suited to while loops, which ends when
    the list is sorted.

*** How do I structure my code?
You may recall, that is usually a good idea to avoid
complexity. Rather you want to design your code in small chunks which
you can test individually.  This can be either done by starting with
the overall code structure, and then breaking it down into chunks, e.g.
#+BEGIN_EXAMPLE
While loop which executes until all elements are sorted
      for loop which does a single pass bubble sort
          is swap needed
             swap elements
	     
      decide if we need another pass, 
      or whether we can end the while loop
#+END_EXAMPLE
or by starting with the code fragments you will need, i.e.,
#+BEGIN_EXAMPLE
write code which does the swap
test this

write code which does a single pass bubble sort
test this

embed this code into a while loop
test this
#+END_EXAMPLE
Which approach you choose, depends on the programming problem.  In
this case the termination of the while loop depends on the result of
the for loop which does the bubble sort, which itself depends on the
ability to swap numbers.  So to me, it seems easier to start with the
swapping, followed by the bubble-sort, followed by the while loop.

Next, we need to decide whether we write the code bits as functions,
or whether we all mangle it together. This is a personal choice, and
it will vary with experience. However your code will be easier to read
and easier to test, if you break it down into functions. So you will
need to create the following functions:
 - =swap_list_elements=
 - =single_pass_bubble_sort=
 - =bubble_sort=

The last function will should return the sorted list.

**** Swapping numbers
Here I will provide the code to swap numbers, since it is not obvious
that this is way to go
#+BEGIN_SRC ipython
a :int = 12
b :int = 4
print(a,b)
b, a = a, b # swap the values of a and b
print(a,b)
#+END_SRC

To encapsulate this into a function, consider what parameters
need to be passed, and what kind of return values do we need to pass
back? Clearly, the function will need access to the list, and it needs
to know the index-numbers of the elements you want to swap.

You may recall, that what happens in a function, stays in a
function. But you may also recall, that function arguments are passed
as reference. So we do not pass the list values, rather we pass the
location where the list is stored. This opens a door to something like this:
#+BEGIN_SRC ipython

def mydef(l :list):
    """ Demonstrate how lists are passed by reference, and not by value
    """
    l[1] = "a"

# --- code
ml :list = [1, 2, 3]
mydef(ml)
print(ml)
#+END_SRC


uggh, so the function is able to modify the list without explicitly
returning the changed list. This is possible because pythons lists are
a mutable data type (this would not work with a tuple, please try the
above statements with a tuple). Programmers refer to this as a "side
effect". Side effects should be avoided like the plague since they
create hard to debug code. So, to do this properly, we need to pass a
copy of the list, rather then the reference. @@latex:\index{list!copy}
\index{list()!function} \index{functions!list()}@@ We can do this with
the builtin =list()= function. This function simply creates a new list
from whatever list is provided as argument.

#+BEGIN_SRC ipython

def mydef(l :list):
    """ Demonstrate how lists are passed by reference, and not by value
    """
    l[1] = "a"

# --- code
ml :list = [1, 2, 3]
mydef(list(ml)) # pass a copy of the list, rather then the reference
print(ml)
#+END_SRC

Now all you need to do is to add a return statement to return the changed list:
#+BEGIN_SRC ipython
def mydef(l :list) -> list:
    """ Demonstrate how lists are passed by reference, and not by value
    """
    l[1] = "a"
    return l

# --- code
ml :list = [1, 2, 3]
ml = mydef(list(ml)) # pass a copy of the list, rather then the reference
print(ml)
#+END_SRC
Yes, this code is longer then the initial example, but it is also much
cleaner, since you explicitly state that you pass a copy of =ml=, and
then overwrite =ml= with the return value of =mydef()=.  OK, I think
you are ready to write and test your swap function.


**** Single pass bubble sort
Now that your swapping code works, you can forget everything about it,
and focus your attention on the next step, the bubble sort function. If
you already forgot what is this about, go back to the top of this
document.

 - What are the arguments you need to pass to the single pass bubble
   sort function? -> A list
 - What are the return values(s) you need to pass to the calling code
   -> A modified list, and what else? Here you need to consider how
   the calling code will decide if another sorting pass is needed? Is
   there some sort of information which will be useful towards this
   end, which you can pass back to the while loop?

If a python function returns more than one value, it does so by
returning a tuple. Tuple annotation is not yet fully implemented in
python 3, so we need to import the typing library first, and we can
then write a properly annotated function skeleton
#+BEGIN_SRC ipython
from typing import Tuple


def single_pass_bubble_sort(l: list) -> Tuple[list, bool]:
    """
    """
    complete :bool = False # is more sorting needed?
    # insert your code below
    
    return (l, complete)
#+END_SRC


Test your single pass sorting code with a statement like this:
#+BEGIN_EXAMPLE
print(l)
a,l=single_pass_bubble_sort(l)
print(l)
#+END_EXAMPLE
If all works well, the largest value should become the last value in
the list.


**** The while loop
Again, forget everything about the internal workings of the single
pass bubble sort, and consider how to structure your while loop.  How
long does it have to run, and how will you decide whether it should
stop?  Wrap your while loop into a function called =bubble_sort= and
test you code with these statements:
#+BEGIN_SRC ipython
l :list = [1, 3, 2, 10,3, 8, 7, 5, 6, 12, 11 ,4]
print(l)
l = bubble_sort(l)
print(l)
#+END_SRC


** Notes
Some pointers

   - If things don't go as expected, use print statements to trace
     what goes wrong.
   - If your notebook cell shows an asterisk, it indicates that the
     code is currently running. Likely a while loop with faulty
     logic. (Says the wife to her programmer husband: while you are
     out, can you get some milk? He never returned home.... ) If this
     happens, use the kernel menu and select "Interrupt". Recheck your
     logic, maybe add some print statements... and restart the kernel.
   - For your final submission, use the submission template below, and
     re-work each subsection as necessary.
   - The idea is to practice functions, loops, if's, and passing
     arguments back and forth...
   - Last but not least, if you do get stuck, post your questions on
     the Quercus discussion board.

** Marking Scheme (34 pts)

- Correct notebook name: 1pt
- Required notebook header 1pt
- Code planning: 6 pts
- Code:
  - Proper docstrings (functions, and program) 2 pst each for a total
    of 8pt
  - Correct variable definitions 2 pts
  - Type hinting used throughout 8 pts
  - Working code: 2 pt for the swap code, 2 pt for the single pass
    sorting, 2 pts for the bubble sort, 2 pts for the main code (8pts)
 
** Submission template

Add the usual headers here

*** Code Plan
Fill in and expand this template:   
  1. Restate the problem in your own words: ...
  2. Enumerate the individual substeps, and create a code cell for
     each step. Use these cells to enter your actual code and to test it:
     1. Testing ....
	#+BEGIN_SRC ipython
	# your first code piece here
	#+END_SRC
     do the same for for the next sub-step(s).

** Final code
Use this template to assemble your final code into a single notebook cell
#+BEGIN_SRC ipython
""" Description:
Purpose
Example
Limitations
Author:
Date:
"""
# ----------- functions definitions  -----------------------

# ----------- main program ---------------------------------
# --- variable declarations

# --- code starts here
#
#+END_SRC
