#+STARTUP: showall
#+OPTIONS: todo:nil tasks:nil tags:nil toc:nil
#+PROPERTY: header-args :eval never-export
#+EXCLUDE_TAGS: noexport
#+LATEX_HEADER: \usepackage{breakurl}
#+LATEX_HEADER: \usepackage{newuli}
#+LATEX_HEADER: \usepackage{uli-german-paragraphs}



* Decimal to Binary Conversion


Write python code which will convert an arbitrary decimal number (must
be a positive integer though) into it's binary notation.

Your code should ask for user input until the user types the character
"s". After that your code should end with a goodby message. See this
example session:
#+BEGIN_EXAMPLE
Please enter a positive integer number or 's' to end program

123

Convverting 123 into binary notation yields 1111011

s

Good bye!
#+END_EXAMPLE


 Once you
have the user input, tests whether the input is positive, and of type
integer. For this you can use the string method isdigit, i.e., =s =
"123"= and then call =s.isdigit()=.  Test this right here with a
variety of values:
#+BEGIN_SRC ipython
s :str = "123"
#+END_SRC
next you need to convert the string to an integer number (=int()) and
test if the number is positive. BTW, what happens if the string
contains a float number? How will you capture this in your code?

If the input, is indeed of type integer and positive, call a homegrown
function which converts from integer to binary. For any other input,
print an error message and request new input. In other words, you will
need the following ingredients:

 - A while loop which handles the user input
 - A function which tests for positive integer
 - A function which converts from integer to binary, and return the
   binary value back to the calling code (i.e., the printing should be
   handled in the calling code, not in the function).

Again, you used all required techniques previously. The challenge with
this assignment is to derive an algorithm which converts a decimal
number into it's binary form. Remember to test each of these
components individually, before assembling the whole program!

** Some pointers

This program should not use the builtin integer to binary
conversion. Rather I want you to be creative with loops and string
manipulation. You may recall that binary numbers are calculated to the
base of 2.

| /             |  < |  < |  < |  < |  < |
| Base          |  2 |  2 |  2 |  2 |  2 |
|---------------+----+----+----+----+----|
| Exponent      |  4 |  3 |  2 |  1 |  0 |
|---------------+----+----+----+----+----|
| Expression    | 2^4 | 2^3 | 2^2 | 2^1 | 2^0 |
|---------------+----+----+----+----+----|
| Result        | 16 |  8 |  4 |  2 |  1 |
|---------------+----+----+----+----+----|
| Binary Number |  0 |  1 |  0 |  0 |  1 |

so the binary number 01001 is equal to the sum
#+BEGIN_EXAMPLE
0 * 16 = 0
1 * 8  = 8
0 * 4  = 0
0 * 2  = 0
1 * 1  = 1
----------
Total  = 9
#+END_EXAMPLE

So if you want to go the other way round, you need to first design a
loop which tests what is the biggest exponent n (i.e. 2^n) that you can
fit in the given number. In the above example, your biggest =n= would
be 3. To achieve this, you will need to use a loop in combination with
a break statement. Consider the example below. If necessary, add print
statements to explore what the break and continue statement do

#+BEGIN_SRC ipython
n :int  = 10
a :bool = True
i :int  = 0
while a:
   i  = i + 1
   if i > n:
       break
   else:
       continue
print(i)
#+END_SRC


Once you know your biggest exponent (in the above example 3), you can
use a second loop which systematically counts down towards zero. This
can be done with a while loop and a counter, or with the range
function.

** Notes

   - Start by testing the individual components of your program first
     (i.e. =dec_2_bin=, =is_int=, the while loop).
   - If things don't go as expected, use print statements to trace
     what goes wrong.
   - For your final submission, use the submission template
     below. Re-work each subsection as necessary.
   - The idea is to practice loops, if's, sums, counters, and strings.
   - Last but not least, post your questions on the quercus discussion
     board. I will check there at least once a day (no promise for the
     weekend though).
   - Test boundary cases like:
     - 0
     - 1
     - 2
     - 8
     - 9
     - 10
     - 0099
     - 100

** Marking Scheme (28 pts)

- Correct notebook name: 1pt
- Required notebook header 1pt
- Code planning:
  - 2 pts, for restating the problem
  - 2 pts for having individual tests for each sub-probblem
  - 2 pts if those snippets work as they should
- Code:
  - Proper docstrings (functions, and program) 2 pst each for a total
    of 6pt
  - Correct variable definitions 2 pts
  - Type hinting used throughout 4 pts
  - Working code: 2 pt for the while loop, 2 pt for the =dec_2_bin=
    function, 2pts for the =is_int= function. Total 6 pts
  - Result printed according to the above template 2pt


** Submission template

Add the usual headers here

*** Code Plan
Fill in and expand this template:   
  1. Restate the problem in your own words: ...
  2. Enumerate the individual substeps, and create a code cell for
     each step. Use these cells to enter your actual code and to test it:
     1. Testing ....
	#+BEGIN_SRC ipython
	# your first code piece here
	#+END_SRC
     do the same for for the next sub-step(s).

** Final code
Use this template to assemble your final code into a single notebook cell
#+BEGIN_SRC ipython
""" Description:
Purpose
Example
Limitations
Author:
Date:
"""

# ----------- functions definitions  -----------------------

# ----------- main program ---------------------------------
# --- variable declarations

# --- code starts here
#
#+END_SRC






