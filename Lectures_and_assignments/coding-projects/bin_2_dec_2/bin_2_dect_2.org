#+STARTUP: showall
#+OPTIONS: todo:nil tasks:nil tags:nil toc:nil
#+PROPERTY: header-args :eval never-export
#+EXCLUDE_TAGS: noexport
#+LATEX_HEADER: \usepackage{breakurl}
#+LATEX_HEADER: \usepackage{newuli}
#+LATEX_HEADER: \usepackage{uli-german-paragraphs}

** TODO use full code for each step. Otherwise student will execute code and it will fail

** need more explanations and examples on functions including the us of return values

** 

* Binary to decimal Revisited



\index{Complexity!Avoid} In the last exercise, many of you started
coding right away, and soon getting stuck with code which either was
not running at all, or with code which did weird things. This was
caused by a tricky mixture of syntax errors \index{Syntax!Errors}
\index{Errors!Syntax} which went undiscovered by the python
interpreter.

The bad news is, that this will happen again, and again, and again....
The good news is, that there are strategies to minimize these hard to
detect errors. You already started to use type hinting, which
hopefully will help you to catch mistakes like comparing a string
element to a number.

The most effective strategy, however, is to avoid complexity in the
first place. In the following I will walk you through this step by
step, using our last assignment as example. I assume that your code
planning has already been done, and I will omit all docstrings, and I
will not repeat variable definitions. You will need to execute each
code block sequentially for the below examples to work.

The first objective is to create a program skeleton \index{Program
Skeleton} which executes without error.
#+BEGIN_SRC ipython
""" Program skeleton which will simply print the vlaue of two variables
in the required format

Example:

    '000' equals 0 in decimal notation
"""
# first we declare all variables we are going to use

# Parameters, i.e., variables you expect to change frequently
b :str = "000"  # string with a binary number

# Scalar Variables
d :int = 0 # the result of the conversion

# Other data types

result :str = f""     # fstring to display the result

# --------------------- Code -------------------*

result = f"{b} = {d} in decimal notation"
print(result)
#+END_SRC

After executing the above successfully, we have a working
\index{Program Prototype} prototype. In the next step we add the loop
and test whether it executed correctly.
#+BEGIN_SRC ipython
b_r :str    = b[::-1] # a string with the reverse of b
e :str  = "" # individual element of b_r

# --------------------- Code -------------------*
# loop over elements in string b_r
for e in b_r:
    print(f"e = {e}")

result = f"{b} = {d} in decimal notation"
print(result)
#+END_SRC

Once we have the loop, let's add the if statements and a test whether
our if statement works. This simple test, would have caught half your
errors. 
#+BEGIN_SRC ipython
# loop over elements in string b_r
for e in b_r:
    if e == "1":
        print(f"e == 1 condition met e = {e}")
    else:
        print(f"e == 0 condition met e = {e}")

result = f"{b} = {d} in decimal notation"
print(result)
#+END_SRC

In the next step, we add the counter =n=
#+BEGIN_SRC ipython
n :int  = 0   # index of element in b_r

# --------------------- Code -------------------*
# loop over elements in string b_r
for e in b_r: 
    if e == "1":
        print(f"e == 1 condition met n = {n} e = {e}")
    else:
        print(f"e == 0 condition met n = {n} e = {e}")
    n = n + 1  # increase the counter

result = f"{b} = {d} in decimal notation"
print(result)
#+END_SRC
Last but not least, lets add the math which computes 2^n each time e
equals "1" and which calculates the sum of these results. For clarity,
I added the variable =p= in the following code, and removed the
superfluous print statements. If your code behaves unexpectedly, you
may want to keep them until you have resolved the issue.
#+BEGIN_SRC ipython
p :int  = 0   # 2^n

# --------------------- Code -------------------*
# loop over elements in string b_r
for e in b_r: 
    if e == "1":
        p = 2**n  # calculate 2 to the power of n
    else:
        p = 0     # if the bit is not set, p will be zero
    d = d + p     # calculate the sum of all 2^n
    n = n + 1     # increase the counter

result = f"{b} = {d} in decimal notation"
print(result)
#+END_SRC
The above code is rather explicit, and it can be easily made more
compact. I.e., you could merge the statements which calculate 2^n and
which calculate the sum of these powers. But it is always a delicate
balance between being to verbose, and being to terse. Similar to
writing a term paper, your style will evolve over time. For now, let's
err on the side of verbosity.


** Making it interactive
Rather than editing the code block each time we want to convert a
binary number into it's decimal version, it would be nice if we could
prompt the user for feedback. \index{user input}
\index{Functions!input()} \index{input()} This is achieved with the
input function
#+BEGIN_SRC ipython  
prompt :str = "Please enter a binary number "
answer :str = "" # The result returned by the input function
answer = input(prompt)
print(f"The answer was {answer}")
#+END_SRC

It would be even better if we could do this repeatedly without having
to use =shift-enter= again and again. We can achieve this by embedding
the input statement into a =while= loop. The =input()= function will
wait for you to type something, and then return whatever you typed as
a result.
#+BEGIN_SRC ipython
a :bool = True   # We use this criterion for the while loop
answer :str = "" # the user input as a string
prompt :str = "Please enter a binary number \nExit by hitting the s-key"

while a: # do this as long as a = True
    answer = input(prompt) # get user input
    if answer == "s":
       a = False # this will end the while loop
       print("\nGood bye\n")
    else:
        print(f"You entered '{answer}'")
#+END_SRC


** Using a Functions to declutter your code

In the above example, the else part becomes pretty cluttered once you
add the code which tests whether the string contains a binary
number. It would be great, if python would have a function which could
do this test for us, sadly, it does not. However, nothing prevents us
from extending the capabilities of the python language. We can do so
by defining our own functions. This is done with the =def= statement,
which is basically a block statement which allows us to refer to a
block of code lines by name.  Consider the following mini example.
#+BEGIN_SRC ipython
"""This program will print Hello World

"""
print("Hello World")
#+END_SRC
Now, lets turn this into a named code-block using 
the =def= block statement.
#+BEGIN_SRC ipython
def hello():
    """This program will print "Hello World"
    """
    print("Hello World")
#+END_SRC
The =def= statements is followed by the name of the block, which is
followed by a pair of brackets (more on this below), which is followed
by the colon. As with other block statements, everything after the
colon is indented. And the block ends on with the first line which is
no longer indented. If you execute this block, you will note that it
does not produce any output.  Unlike before, executing the above cell
will define the =hello()= block, but it will not run it. In order to
execute the program code inside the =hello()= block, we have to call
it by it's name
#+BEGIN_SRC ipython
hello()
#+END_SRC
since our code block now has a name, we can use the help function to
display the information we put into the doc-string:
#+BEGIN_SRC ipython
help(hello)
#+END_SRC

I we want to use such a block to act on some data, we also need a way
to pass data (i.e., the value of a variable) to it, and to return the
result of whatever you do in this block. This is done with arguments
which are enclosed in the brackets after the name, and with the return
statement at the end. These type of blocks are usually referred to as
"function". Consider this:
#+BEGIN_SRC ipython
def mff(s):  # my first function
    """ This function returns the length of the string s
    """
    l = len(s)
    return l
#+END_SRC
let's decompose the above code. We define a new code block named
=mff=.  Next we add a variable-name inside of the brackets (=s=). This
variable name will only be known inside the function, and is
completely independent of the variables used outside of the
function. So if you call =mff= like this =mff(b)= b will be known
inside the function as =s=. Likewise, if you have a variable s outside
the function, it will not be changed by whatever you do with s inside
the function (but see below). Technically this is referred to as that
functions have their own name space. The last line will return the
value of l back to the calling program. Again, =l= will only be known
inside the function, and once the function has finished, all trace of
these variables will be lost.

Execute the above block to define the function and then try the
following
#+BEGIN_SRC ipython
a = "Some words"
x = mff(a)
print(f"The length of the string '{a}' = {x}")
#+END_SRC
Neat, we taught python a new trick (and yes, I know that there is
already the =len()= function - but it is the principle which counts).
Also, try calling =mmf= without ant arguments (i.e., =mff()=).

For good measure, let's add type hinting to the function definition
#+BEGIN_SRC ipython
def mff(s :str) -> int :  # my first function
    """ This function returns the length of the string s
    """
    l :int = len(s)
    return l
#+END_SRC
The type hint inside the brackets is straight forward. Noteworthy is
the one after the brackets. It signifies that this function will
return an integer value.  Note that this type-hint does not use the
colon, since it would conflict with the colon used to signal the start
of the block.

Last but not least: 

 - All functions should have a doc string explaining what the function
   does, what arguments are expected, and what will be returned.

 - Although functions have their own name space, you may recall that
   python objects like lists are referenced by their memory
   location. So if you pass a list and than delete an element from
   this list in a function, this element will also be gone once the
   function returns to the main program. In such cases, you need to
   explicitly copy the list first. In other words, a function should
   never modify the data which is passed as an argument. If such
   modifications are necessary, it should return a copy of the data on
   which these modifications where performed.

 - All functions need to be defined and executed before they can be
   used. In other words, the cell containing the function definition
   must precede the cell where you use the function. More on this in a
   later module.

Enough theory. Create your own function which will test whether your
input is a binary number or not. Let's call this function
=is_binary()=, and add it to your code. I provide a skeleton below.
#+BEGIN_SRC ipython
def is_binary(s :str) -> bool:
    """This function evaluates whether the string s constitutes a binary
    number or not. If so, it returns a True value, and if not, False
    usage: if(is_binary(s))
    """
    r :bool = False
    # Add your code here
    # if is a inary number
    r = True
    return r
#+END_SRC
Please test your function before adding it to your while loop.
#+BEGIN_SRC ipython
print(is_binary("001")
#+END_SRC

Note that functions, should always take a value and return a value,
i.e., you want your function to return the value of =r= to the calling
program, and that it is up to the calling program to do something with =r=.



* Assignment
Functions can be a great way to declutter your code, and to test
smaller code units. This also helps with reducing complexity, and
allows you to develop your code step-wise.

For this assignment, you have to create a program which will ask for
the user to input a binary number until the user enters =s=. The code
shall then test whether the entered string is indeed a binary
number. If not, the code shall print a warning, and ask for a new
entry. If your string is a binary, call a function which converts the
string into a decimal number.
Using pseudo code, your code should look like this:
#+BEGIN_EXAMPLE
# first we define the functions we need

def is_binary(a)
    # test if a is a binary numer

def bin_2_dec (b)
    # convert string b to binary mumber
    if is_binary(b) # test if string is binary
        convert string
    else
        return

# ---- start of main program -----

while loop over input
    if input == "s"
       terminate loop
    else 
       if (is_binary)
           bin_2_dec(input)
  
   
#+END_EXAMPLE

Your code should print a successful conversion as
#+BEGIN_EXAMPLE
Converting '0010' into decimal notation yields 2
#+END_EXAMPLE
Your numbers will obviously be different.

** Notes

   - You have all the code fragments for this task, but you will have
     to convert your =bin_2_dec= program into a function.
   - Start by testing the individual components of your program first
     (i.e. =bin_2_dec=, =is_binary=, the while loop).
   - If things don't go as expected, use the print statements to trace
     what goes wrong.
   - For your final submission, use the coding template provided last
     time. Re-work each subsection as necessary.
   - Your code should only use loops and conditional statements to
     test the input and perform the bin to dec conversion (rather than
     built-in functions). The idea is to practice these techniques....

** Marking Scheme (31 pts)

- Correct notebook name: 1pt
- Required notebook header 1pt
- Code planning: 9 pts, one for each subsection with the exception of
  Data-structures (2pt), and Pseudo-code (4pt)
- Code:
  - Proper docstrings (functions, and program) 2 pst each for a total
    of 6pt
  - Correct variable definitions 2 pts
  - Type hinting used throughout 4 pts
  - Working code: 2 pt for the while loop, 2 pt for the =bin_2_dec=
    function, 2pts for the =is_binary= function. Total 6 pts
  - Result printed according to the above template 2pt
