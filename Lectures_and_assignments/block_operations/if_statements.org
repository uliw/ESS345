#+STARTUP: showall
#+OPTIONS: todo:nil tasks:nil tags:nil toc:nil
#+PROPERTY: header-args :eval never-export
#+PROPERTY: header-args :results output pp replace
#+EXCLUDE_TAGS: noexport
#+LATEX_HEADER: \usepackage{breakurl}
#+LATEX_HEADER: \usepackage{newuli}
#+PROPERTY: header-args :results output pp replace
#+LATEX_HEADER: \usepackage{uli-german-paragraphs}





* If statements


@@latex:\index{program flow} \index{block statements}@@ The last
module explored the use of comparison operators that return truth
values. To branch the sequence of execution in our code depending on a
given circumstance, we will need a statement that takes a truth
(boolean) @@latex:\index{boolean value} \index{truth value}@@ value
and allows us to create two groups of code. One gets executed if the
statement is true, and another block gets executed when the statement
is false.

@@latex:\index{if clause} \index{if clause!else} \index{block statements!if}@@
Most programming languages know a variation of the so-called if-then-else
clause. The =if= part expects a truth value and executes the code followed after
the =then= in case the value is =True=. In the case of a =False=, it will
execute the part after the =else=. This is pretty straight forward, and the only
other ingredient needed is a way to group programming code. 

*In python, all block statements end with a colon, and the code* group
*following this block statement has to be indented.* You end the code
*block by returning to the previous indention level. See this example:
#+BEGIN_SRC ipython
a = 10
if a > 10:  # theh result of the comparison is either True or False
    message = f"a = {a} which is larger than 10"
else:
    message = f"a = {a} which is euqal or smaller than 10"

print(message)
#+END_SRC

#+RESULTS:
: # Out [4]: 
: # output
: a = 10 which is smaller than 10
: 

Note the use of the colon after the comparison statement. This colon indicates
to python that you are starting a new code block. Your editor will then
automatically indent the next statement. If it does not, you have some sort of
syntax error. You will also note that the else statement is followed by a colon,
indicating the beginning of the second code block. Last but not least, you will
note that python has no keyword to end a block. The simple fact that the print
statement has been moved back to the left indicates that the else block has ended.
It is an easy mistake to change indentation and thus change the way your code
works. To get a feel how your editor supports you in writing code blocks, the
type the above example into this box, and execute your code
#+BEGIN_SRC ipython
a = 8
#+END_SRC

#+RESULTS:
: # Out [5]: 

Test your code with values which are larger than 10 to see if it indeed does
what it is supposed to do. Next, change the indentation of the print statement,
and execute your code again for values smaller and larger than 10.

*** Multiway branching
@@latex:\index{if clause!elif}@@ 
@@latex:\index{if clause!multiway branching}@@ @@latex:\index{block
statements!if!multiway branching}@@ If statements can contain more than one
condition. Imagine you get data from some analytical machine which outputs the
measured voltage between 0 and 50 volts. You also know that value below 2 V are
not reliable, that value above 20 volt are not reliable, and that values of 50 V
indicate a malfunction. This is achieved by the =elif= keyword which stands for
"else if". Check the results of this code against voltage values of 0.2, 4, 22,
and 55.
#+BEGIN_SRC ipython
voltage = 55
if voltage < 2:
    print(f"Your sample is to small")
elif voltage > 2 and voltage < 20:
    print(f"Voltage = {voltage}V")
elif  voltage > 20 and voltage < 50:
    print (f"Your sample is to big")
elif voltage > 50:
    print("---------------------------------")
    print (f"\n\nAttention: Instrument malfunction!\n\n")
    print("---------------------------------")
else:
     print (f"You should never see this")
#+END_SRC

#+RESULTS:
#+begin_example
# Out [6]: 
# output
---------------------------------


Attention: Instrument malfunction!


---------------------------------

#+end_example



*** Nested blocks
@@latex:\index{block statements!nested if} \index{nested blocks}@@
Code blocks can be nested into each other. We could e.g., rewrite the above example as
#+BEGIN_SRC ipython
voltage = 0.1
if voltage < 50:
    if voltage <= 20:
        if voltage > 2:
            print(f"Voltage = {voltage}V")
        else:
            print(f"Your sample is to small")
    else:
        print(f"Your sample is to big")
else:
    print("---------------------------------")
    print(f"\n\nAttention: Instrument malfunction!\n\n")
    print("---------------------------------")
#+END_SRC

#+RESULTS:
: # Out [7]: 
: # output
: Your sample is to small
: 

As you can see, the nested block has simply shifted another
indentation level to the right. Also note, that this code is
functionally equivalent to the previous example, but it is much harder
to figure out what it does.  Similar to joining comparison operators
with logic operators, it pays to carefully think about the required
logic, and simplify it is much as possible.



*** Pitfalls
@@latex:\index{block statements!if clause!pitfalls}@@
@@latex:\index{block statements!pitfalls!if clause!}@@  The execution of
multiway branching statements stops with the first true condition. As
such, conditional statements that follow afterward may never be
tested. Care is needed in designing such statements.


*** The pass statement
@@latex:\index{block statements!pass statement}@@ Sometimes you need to write code where
the truth value requires no action, and only the else part contains code. Simply
omitting the code will cause a and indentation error because there is no code
after the =if=
#+BEGIN_SRC ipython
a = 14
if a < 12:
else:
    a = a * 12
    print(a)
#+END_SRC

#+RESULTS:
: # Out [8]: 
: # output
:   File "<ipython-input-8-c65c3115f979>", line 3
:     else:
:        ^
: IndentationError: expected an indented block
: 

In this case, all we need to do is to add the =pass= statement
Unlike a comment, this is an actual python command, which does
nothing (try to use a comment instead).
#+BEGIN_SRC ipython
a = 14
if a < 12:
    pass
else:
    a = a * 12
    print(a)
#+END_SRC

#+RESULTS:
: # Out [10]: 
: # output
: 168
: 

If you are really on the ball, you will have noticed that we also
could have used the =not= statement:
#+BEGIN_SRC ipython
a = 14
if not (a < 12):
    a = a * 12
    print(a)
#+END_SRC

#+RESULTS:
: # Out [9]: 
: # output
: 168
: 

which will work just fine. While more compact, it requires a bit more
thinking to figure out what is going on. My advice is to use pass, and
avoid negation where possible.


** Ternary Statements
@@latex:\index{block statements!ternary} \index{ternary statements}@@
Python supports an abbreviated form of writing logic and conditional
expressions. Personally, I think they are bad style because it is not
immediately obvious what the code is trying to achieve. However, you
should be at least aware that this kind of syntax exists:
#+BEGIN_SRC ipython
a = ''
b = 'Some text'
c = "more text"
x = a or b or c or None
print(x)
#+END_SRC

#+RESULTS:
: # Out [11]: 
: # output
: Some text
: 

This assigns the value of the first non empty object to x.  Similarly, you can
write
#+BEGIN_SRC ipython
a = 13
b = 5
x = 16 if a > 12 else 22
print(x)
#+END_SRC

#+RESULTS:
: # Out [12]: 
: # output
: 16
: 

explore this for various values of =a=

BTW, why am I so obsessed with clarity versus brevity? As a
programmer, you will spend 90% of your time looking at code trying to
figure out what is going on in front of you., Only a small fraction of
your time is spend creating code. There are in fact extremely powerful
and elegant programming languages out there. But they never gained
popularity because it is so hard to understand what the program is
doing. A good example is IMB's APL (Advanced programming
language). The following is a complete APL program which implements  [[https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life][Conway's Game of Life]]. 


[[./Screenshot_20200708_102345.png]]


pretty slick, but good luck understanding how this works.

