#+STARTUP: showall
#+OPTIONS: todo:nil tasks:nil tags:nil toc:nil
#+PROPERTY: header-args :eval never-export
#+PROPERTY: header-args :results output pp replace
#+EXCLUDE_TAGS: noexport
#+LATEX_HEADER: \usepackage{breakurl}
#+LATEX_HEADER: \usepackage{newuli}
#+PROPERTY: header-args :results output pp replace
#+LATEX_HEADER: \usepackage{uli-german-paragraphs}

** TODO

this needs tailored assignments before going to bin to dec


* Loop statements
In the previous module, we used if-statements to group several lines of code
together into a code block. By combining if-statements with the result of
comparisons, we were able to change which code gets executed. In other words, we
can branch our code. Say if variable =a= is larger than 5, execute lines 12-200,
and if variable =a= is smaller than 5 execute lines 1 to 9. If =a=5= print
"bingo!". While this allows us already some flexibility, we need another piece
to make computer code really useful. Remember that computers are best suited to
repetitive tasks. So we do need a structure which allows us to repeat a block of
code. This is where the loop statements come in.  @@latex:\index{block
statements!loop} \index{loop statement}@@ 

There are two types of block statements which facilitate repetition: the
"for-loop" which executes a given number of times, and the 'while loop' which
executes until some condition is met. We will look at the 'or loop' first:
#+BEGIN_SRC ipython
my_list = [1, 2, 3, 4]

for a in my_list:
    print(a)
#+END_SRC

#+RESULTS:
: # Out [13]: 
: # output
: 1
: 2
: 3
: 4
: 

** The for-loop
@@latex:\index{block statements!for loop} \index{for loop}@@ The above code uses
a so-called "for-loop". The arguments to the for loop are the name of the
variable which will hold individual values of the list (in this case =a=), and
the name of the list, followed by a colon, which denotes the start of the
block. The name of the variable we use as the first argument does not
matter. The for statement will iterate over each element of the =my_list= and
for each iteration assign the value of the current element to =my_element= (or
=a= in the above case)
#+BEGIN_SRC ipython
my_list = [1, 2, 3, 4]

for my_element in my_list:
    print(my_element)
#+END_SRC

#+RESULTS:
: # Out [14]: 
: # output
: 1
: 2
: 3
: 4
: 

This will work with any list type object
#+BEGIN_SRC ipython
my_string ="Hello World"

for my_element in my_string:
    print(my_element)
#+END_SRC

#+RESULTS:
#+begin_example
# Out [15]: 
# output
H
e
l
l
o
 
W
o
r
l
d

#+end_example

and we can use the usual slicing statements
#+BEGIN_SRC ipython
my_string ="Hello World"

for my_element in my_string[0:-1:2]:
    print(my_element)
#+END_SRC

#+RESULTS:
: # Out [16]: 
: # output
: H
: l
: o
: W
: r
: 

#+BEGIN_SRC ipython
my_string ="Hello World"

for my_element in my_string[::-1]:
    print(my_element)
#+END_SRC

#+RESULTS:
#+begin_example
# Out [17]: 
# output
d
l
r
o
W
 
o
l
l
e
H

#+end_example


*** Adding counters:
@@latex:\index{block statements!for loop!counters}@@ \index{for loop
statement!counters} @@latex:\index{counters!loop statements}@@ Sometimes you
need a simple counter which counts how many times the loop has been
executed. Consider this:
#+BEGIN_SRC ipython
my_string = "Hello World"
i = 0

for a in my_string:
    print(f"List item #{i} = {a}")
    i = i + 1 # you will also see i += 1 which does the same
#+END_SRC

#+RESULTS:
#+begin_example
# Out [18]: 
# output
List item #0 = H
List item #1 = e
List item #2 = l
List item #3 = l
List item #4 = o
List item #5 =  
List item #6 = W
List item #7 = o
List item #8 = r
List item #9 = l
List item #10 = d

#+end_example

Note that it is essential that you initialize the value of =i= before you start
the loop, and it matters where in the loop you increment the counter.

** For loops without a list type object
@@latex:\index{block statements!for loop!range} \index{for loop!range()}@@
@@latex:\index{functions!range()!loop statements}@@ \index{range()!loop
statements} Lets say we want to calculate the $2^n$ for n from zero to eight. You
can go ahead and create a list with =[0,1,2,...]= but this is not really
practical for longer sequences. What we need is a way to create a list on the
fly. Python offers several ways, but here we will only use the range expression:
#+BEGIN_SRC ipython
for i in range(6):
    print(i)
#+END_SRC

#+RESULTS:
: # Out [19]: 
: # output
: 0
: 1
: 2
: 3
: 4
: 5
: 

The arguments are the same we use for slicing, start, stop, step, and
similarly, you can count backwards too
#+BEGIN_SRC ipython
for i in range(6,-1,-1):
    print(i)
#+END_SRC

#+RESULTS:
#+begin_example
# Out [20]: 
# output
6
5
4
3
2
1
0

#+end_example

back to our original problem:
#+BEGIN_SRC ipython
# This script will caculate 2^n for a sequence of numbers
start = 0 # the start value
stop  = 8 # the end value. Note, the last number in the range will be
          # stop-1. This is similar to the slicing expressions!
step  = 1 # the step size

for n in range(start,stop,step):
    r = 2**n
    message = f"2^{n} = {r}"
    print(message)
#+END_SRC

#+RESULTS:
#+begin_example
# Out [21]: 
# output
2^0 = 1
2^1 = 2
2^2 = 4
2^3 = 8
2^4 = 16
2^5 = 32
2^6 = 64
2^7 = 128

#+end_example

** While loops
@@latex:\index{block statements!while loop} \index{while loop}@@ The other
important loop type is the while loop. This type of loop executes until a truth
value (aka condition) changes.

consider the following somewhat pointless code which calculates the square values of =a= but only
as long as the result is smaller than 36.
#+BEGIN_SRC ipython
a = [1, 2, 3, 4, 5, 6, 7, 8]
r = 0

for e in a:
    r = e * e
    print(r)
    if r >= 36:
        break
    
print("finished")
#+END_SRC

#+RESULTS:
#+begin_example
# Out [11]: 
# output
1
4
9
16
25
36
finished

#+end_example

The code above is easy to understand, note however the use of the =break=
statement which interrupts the loop prematurely @@latex:\index{block
statements!break}. While functional, the code is a bit convoluted. Using a while loop, we can rewrite this much more readable as
#+BEGIN_SRC ipython
a = [1, 2, 3, 4, 5, 6, 7, 8]
r = 0
i = 0

while r < 36: # do this as long as r is smaller than 36
    r = a[i] * a[i]
    i = i + 1
    print(r)
    
print("finished")
#+END_SRC

#+RESULTS:
#+begin_example
# Out [12]: 
# output
1
4
9
16
25
36
finished

#+end_example


While both loops achieve the same the logic of the second loop is much easier to
understand. Note that the above example the variable =r= essentially acts a
switch. So we need to initialize it's value, otherwise the while-loop never
turns on.  While loops are super useful, when you write code which has to wait
for an event, e.g., you wait for user to press a button:

#+BEGIN_SRC ipython
a = True # we need to initialize a,  otherwise the while loop will
         # never execute
while a: # do this until a becomes False
    print("\nStop this by hitting the s-key")
    my_input = input("Hit any other key to continue:")
    if my_input == "s":
       print("\nGood bye")
       a = False
    else:
        print(f"\nYou pressed the '{my_input}' key")
    
#+END_SRC

However, you need to think carefully about your logic. A famous programmer joke goes like this:
#+BEGIN_QUOTE
A programmer goes out to get some dry cleaning. His wife told him, "While you're out, pick up some milk"

He never came home...
#+END_QUOTE
If you are ever in the situation that your while loop never stops, hit the "stop
kernel" button in your notebook menu. Sometimes it also a good idea to use an
if-clause to create manual limit on how often a loop can run.


** Advanced loop features

Python loops support a couple of features that were not mentioned above. Most
of these you will not need for this course, but you should at least have heard
about it.
 - The =continue= statement sill stop the execution at the current line and jump
   back to the header of the loop (i.e., execute the next iteration)
   @@latex:\index{block statements!loop!continue}@@ \index{loop
   statement!continue} @@latex:\index{continue!block statements!loop}@@
 - The =break= statement will jump out of the loop. This is often used with
   nested loops @@latex:\index{block statements!loop!break}@@ \index{loop
   statement!break} @@latex:\index{continue!block statements!break}@@
 - The =else= statement, is run only if the loop ends regularly. Most useful in
   combination with the break statement \index{block statements!loop!esle}
   @@latex:\index{loop statement!else}@@ @@latex:\index{continue!block
   statements!break}@@
 - The =pass= statement does nothing, but can be used to improve code clarity
   @@latex:\index{block statements!loop!pass}@@ \index{loop statement!pass}
   @@latex:\index{continue!block statements!pass}@@

*** List comprehensions
@@latex:\index{list comprehensions} \index{for loop!list comprehension}
\index{block statements!list comprehension}@@ We already know that python makes
it very easy to iterate through the elements of a list. We can use this e.g.,
calculate the squares of a given sequence, and save the results into a new list:
#+BEGIN_SRC ipython
my_list = [1, 2, 3, 4]
list_of_squares = []

for n in my_list:
  list_of_squares.append(n**2)

print(list_of_squares)
#+END_SRC

#+RESULTS:
: # Out [23]: 
: # output
: [1, 4, 9, 16]
: 


Python provides are more concise way to do this, called list-comprehension
#+BEGIN_SRC ipython
my_list = [1, 2, 3, 4]
list_of_squares = [n**2 for n in my_list]

print(list_of_squares)
#+END_SRC

#+RESULTS:
: # Out [24]: 
: # output
: [1, 4, 9, 16]
: 

In the above expression, the first entry is the function which should
be executed for each element of =my_list=. I personally, and many
experienced programmers consider this bad style. It surely will add
to your geek credentials, but results in difficult to read code, with
no other benefit other than saving two lines. But again, you will come
across this, so you need to know about it.

Also note that list comprehensions can be combined with conditionals 
#+BEGIN_EXAMPLE
[f(x) for x in sequence if condition]
#+END_EXAMPLE



