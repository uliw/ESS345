#+STARTUP: showall
#+OPTIONS: todo:nil tasks:nil tags:nil toc:nil
#+PROPERTY: header-args :eval never-export
#+PROPERTY: header-args :results output pp replace
#+EXCLUDE_TAGS: noexport
#+LATEX_HEADER: \usepackage{breakurl}
#+LATEX_HEADER: \usepackage{newuli}
#+PROPERTY: header-args :results output pp replace
#+LATEX_HEADER: \usepackage{uli-german-paragraphs}

 

 

* Loop statements


@@latex:\index{block statements!loop} \index{loop statement}@@ Coding
would be pretty pointless if we have to execute each piece of code
manually. Being able to repeatedly apply some code to, e.g., each
element of a list is where the true power of computing arises. We do
this with the second class of block statements, the so-called loop
statements. Consider the following list
#+BEGIN_SRC ipython
my_list = ["Garnet", "Apatite", "Quartz", "Pyrite"]
#+END_SRC

#+RESULTS:
: # Out [2]: 

and your task would be to print out each list element on a line by
itself. Yes, you can write four print statements, but this will be tedious
if you start dealing with longer list. It would be a lot simpler if we had
a way to tell python to repeat a given action 4 times. 


** The for-loop
@@latex:\index{block statements!for loop} \index{for loop} \index{for
loop!range}@@ Repeating a given set of instructions for a known number
of repetitions, is the domain of the =for loop=.  You may recall that
we can access list elements via their index, e.g., to access the
second element we can write
#+BEGIN_SRC ipython
my_list[1]
#+END_SRC

#+RESULTS:
: # Out [18]: 
: # text/plain
: : 'Apatite'

Rather than writing the number one, we can use the value of a variable as
index (this is also known as indirection). Doing so, has the advantage that
we can change this value during program execution.
#+BEGIN_SRC ipython
a = 1
my_list[a]
#+END_SRC

#+RESULTS:
: # Out [19]: 
: # text/plain
: : 'Apatite'

So to solve the task of printing each element of =my_list= we only
need a way to repeat code a given number of times, and for each
repetition, we increase the value of =a= by one (i.e., =a= effectively
becomes a counter which increases by one, each time the loop is
executed). 

Python has a variety of ways to execute loops. Most are more elegant
then the example below, but for now, we do it the hard way.  In order
to run a loop, we need to know the number of elements in our list. We
can query the number of list elements with the =len()= function
@@latex:\index{len()} \index{functions!len()}@@. Next we need a way to
specify how many times we want python to execute the loop. For this we
use the the =range()= function. @@latex:\index{range()}
\index{functions!range()}@@ The range function takes three arguments,
the start value, the stop value, and the step size. If set the start
value to 0, the step size to 1, and the stop value equal to the number
of elements in our list, we are ready to execute our first for loop.
#+BEGIN_SRC ipython
a = 0  # will be our counter. Make sure it is zero before you start
noe = len(my_list)  # get the nnumber of elements in my_list

for i in range(0, noe, 1):  # range(start,stop,step)
    print(my_list[a])
    a = a + 1
#+END_SRC

#+RESULTS:
: # Out [3]: 
: # output
: Garnet
: Apatite
: Quartz
: Pyrite
: 

now, what is the function of the variable =i= in the above code?
Lets have a look a what is happening to =a= and =i= during the loop
#+BEGIN_SRC ipython
a = 0  # will be our counter. Make sure it is zero before you start
noe = len(my_list)  # get the nnumber of elements in my_list

for i in range(0, noe, 1):  # range(start,stop,step)
    print(f"a = {a}, i = {i}, my_list[{a}] = {my_list[a]}")
    a = a + 1
#+END_SRC

#+RESULTS:
: # Out [8]: 
: # output
: a = 0, i = 0, my_list[0] = Garnet
: a = 1, i = 1, my_list[1] = Apatite
: a = 2, i = 2, my_list[2] = Quartz
: a = 3, i = 3, my_list[3] = Pyrite
: 

as you can see, =a= and =i= are the same. So we really don't need the
counter =a=, and we can write this more succinctly as
#+BEGIN_SRC ipython
noe = len(my_list)  # get the nnumber of elements in my_list

for i in range(0, noe, 1):  # range(start,stop,step)
    print(f"i = {i}, my_list[{i}] = {my_list[i]}")
#+END_SRC

#+RESULTS:
: # Out [9]: 
: # output
: i = 0, my_list[0] = Garnet
: i = 1, my_list[1] = Apatite
: i = 2, my_list[2] = Quartz
: i = 3, my_list[3] = Pyrite
: 

But how come, that =i= magically counts from 0 to =noe=? The only
thing the range function does, is to generate a list. In python 2, it
returned actual list. However, this is not very effective for large
lists. Imagine,m you have a loop which have to execute 10-million
times...  Starting with python3, the range function instead returns a
range object. Unlike lists, the range object will generate numbers
only on request.

#+BEGIN_SRC ipython
l = range(4)
print(f"l = {l}")
print(f" The type of l = {type(l)}")
#+END_SRC

#+RESULTS:
: # Out [14]: 
: # output
: l = range(0, 4)
:  The type of l = <class 'range'>
: 
to see the actual list which is generated by =l= we can use the =list()= function.
@@latex:\index{list()} \index{functions!list()}@@
#+BEGIN_SRC ipython
list(l)
#+END_SRC

#+RESULTS:
: # Out [15]: 
: # text/plain
: : [0, 1, 2, 3]

OK, back to our original problem. So =range()= returns a list, and the
for loop simply iterates over all list elements. Maybe this works with
any type of list? Let's try with =my_list=


#+BEGIN_SRC ipython
for i in my_list: # for each element in my_list 
    print(i)
#+END_SRC

#+RESULTS:
: # Out [16]: 
: # output
: Garnet
: Apatite
: Quartz
: Pyrite
: 

Notice that =i= is no longer a numerical variable, but rather contains
the value of a given list element. There is also nothing special about
the name of =i=. We could equally write

#+BEGIN_SRC ipython
for mineral in my_list: # for each element in my_list 
    print(mineral)
#+END_SRC

or any other name. 

So there is no need to specify the range, or to reference the list
item by it's index. Rather, python will loop through all list
elements, and at any given time, the current element is available
through the variable you specify after the =for= statement. This will
also work for list wich mix numbers and strings.
#+BEGIN_SRC ipython
mixed_list = [1, "a", "Hello", 12, [1, 2, 3]]
for current_element in mixed_list: 
    print(current_element)
#+END_SRC

#+RESULTS:
: # Out [17]: 
: # output
: 1
: a
: Hello
: 12
: [1, 2, 3]
: 

Lastly, this will work with any object which are related to lists
(iterables in python parlance). So strings will do just fine
#+BEGIN_SRC ipython
my_string ="Hello World"

for my_element in my_string:
    print(my_element)
#+END_SRC

#+RESULTS:
#+begin_example
# Out [15]: 
# output
H
e
l
l
o
 
W
o
r
l
d

#+end_example

and we can use the usual slicing statements
#+BEGIN_SRC ipython
my_string ="Hello World"

for my_element in my_string[0:-1:2]:
    print(my_element)
#+END_SRC

#+RESULTS:
: # Out [16]: 
: # output
: H
: l
: o
: W
: r
: 

#+BEGIN_SRC ipython
my_string ="Hello World"

for my_element in my_string[::-1]:
    print(my_element)
#+END_SRC

#+RESULTS:
#+begin_example
# Out [17]: 
# output
d
l
r
o
W
 
o
l
l
e
H

#+end_example




** While loops
@@latex:\index{block statements!while loop} \index{while loop}@@ The
other important loop type is the while loop. This type of loop
executes until it is switched off (and if your switch does not work,
it will run forever). In other words, while loops are most useful in
combination with if statements.

To give a practical example, any ATM is running a while loop which
shows the greeting screen. This loops runs until you slide your
bank-card into the machine. Then the loop is interrupted, and you are
asked to enter your pin. The below example demonstrates this in a
simple way.

#+BEGIN_SRC ipython
# initialize a as True,  otherwise the while loop will never execute
a = True

# do the while loop until a becomes False
while a:
    # print instructions
    print("\nStop this loop by hitting the s-key")

    # wait for user input
    my_input = input("Hit any other key to continue:")

    # evaluate input
    if my_input == "s":
        print(f"\nYou pressed the '{my_input}' key")
        a = False  # this will stop the while loop
    else:
        print(f"\nYou pressed the '{my_input}' key")

print("\nGood bye")
#+END_SRC
Once our code reaches line 5, it entesr the while loop because
=a=True=. Next it executes line 7, and 10, and then it waits for user
input. If the input equals the =s= key, line 14 and 15 are
executed. Next, the code jumps back to the beginning of the block on
line 5. However, this time, =a=False=. So we do not enter the while
block, rather the code continues on line 19.

If If the input is not equals the =s= key, the code executes line 17,
and jumps back to line 5. Since we did not change the value of a, it
is still true, to we continue with line 7 and 10.

While loops can be tricky if you get your logic wrong. Consider this example before you actually run it
#+BEGIN_SRC ipython
s = True # initialize the switch and set it to no
n = 0    # a counter
while s:
    if my_numbers[n] == 3:
        print(f"my_numbers[{n}] = {my_numbers[n]}")
        s = False
        n = n + 1
#+END_SRC
So here, the counter is inside the if statement. I.e., it will never
increase, because n will stay zero forever. This might have happened
because you missed the flawed logic, or your indention accidentally
changed. If you execute the above cell, you will start an infinite
loop which will run forever. Which begs the question, how would you
know? If you look at the following screenshot, you will the see the
asterisk inside the brackets on the left side of the code box. This
means, that your notebook is busy with your code.

#+name: stuck
#+caption: The asteerisk to the left indicates that your program is busy
[[./Screenshot_20200709_132253.png]]


If this happens, you have to restart your notebook kernel via the kernel menu
#+name: kmenue
#+ATTR_LATEX: :width 5cm
#+caption: Use the kernel menu, if your code is stuck in an infinte loop
[[./Screenshot_20200709_132222.png]]





*** Advanced loop features

Python loops support a couple of features that were not mentioned above. Most
of these you will not need for this course, but you should at least have heard
about it.
 - The =continue= statement sill stop the execution at the current line and jump
   back to the header of the loop (i.e., execute the next iteration)
   @@latex:\index{block statements!loop!continue} \index{loop
   statement!continue} \index{continue!block statements!loop}@@
 - The =break= statement will jump out of the loop. This is often used with
   nested loops @@latex:\index{block statements!loop!break} \index{loop
   statement!break} \index{continue!block statements!break}@@
 - The =else= statement, is run only if the loop ends regularly. Most useful in
   combination with the break statement @@latex:\index{block statements!loop!else}
   \index{loop statement!else}\index{continue!block
   statements!break}@@
 - The =pass= statement does nothing, but can be used to improve code clarity
   @@latex:\index{block statements!loop!pass}\index{loop statement!pass}
   \index{continue!block statements!pass}@@

**** List comprehensions
@@latex:\index{list comprehensions} \index{for loop!list comprehension}
\index{block statements!list comprehension}@@ We already know that python makes
it very easy to iterate through the elements of a list. We can use this e.g.,
calculate the squares of a given sequence, and save the results into a new list:
#+BEGIN_SRC ipython
my_list = [1, 2, 3, 4]
list_of_squares = []

for n in my_list:
  list_of_squares.append(n**2)

print(list_of_squares)
#+END_SRC

#+RESULTS:
: # Out [23]: 
: # output
: [1, 4, 9, 16]
: 


Python provides are more concise way to do this, called list-comprehension
#+BEGIN_SRC ipython
my_list = [1, 2, 3, 4]
list_of_squares = [n**2 for n in my_list]

print(list_of_squares)
#+END_SRC

#+RESULTS:
: # Out [24]: 
: # output
: [1, 4, 9, 16]
: 

In the above expression, the first entry is the function which should
be executed for each element of =my_list=. I personally, and many
experienced programmers consider this bad style. It surely will add
to your geek credentials, but results in difficult to read code, with
no other benefit other than saving two lines. But again, you will come
across this, so you need to know about it.

Also note that list comprehensions can be combined with conditionals 
#+BEGIN_EXAMPLE
[f(x) for x in sequence if condition]
#+END_EXAMPLE



